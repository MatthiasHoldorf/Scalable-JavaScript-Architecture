<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>public\js\libraries\socket.io.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Client_Core_Core.Ajax.js.html">Client_Core_Core.Ajax.js</a></li>
            
                <li><a href="../classes/Client_Core_Core.DomManipulation.js.html">Client_Core_Core.DomManipulation.js</a></li>
            
                <li><a href="../classes/Client_Core_Core.js.html">Client_Core_Core.js</a></li>
            
                <li><a href="../classes/Client_Core_Core.Mediator.js.html">Client_Core_Core.Mediator.js</a></li>
            
                <li><a href="../classes/Client_Core_Core.Socket.js.html">Client_Core_Core.Socket.js</a></li>
            
                <li><a href="../classes/Client_Core_Core.Templates.js.html">Client_Core_Core.Templates.js</a></li>
            
                <li><a href="../classes/Client_Core_Core.Utils.js.html">Client_Core_Core.Utils.js</a></li>
            
                <li><a href="../classes/Client_Main.js.html">Client_Main.js</a></li>
            
                <li><a href="../classes/Client_Modules_chat.js.html">Client_Modules_chat.js</a></li>
            
                <li><a href="../classes/Client_Modules_corkboard.js.html">Client_Modules_corkboard.js</a></li>
            
                <li><a href="../classes/Client_Modules_friend-request.js.html">Client_Modules_friend-request.js</a></li>
            
                <li><a href="../classes/Client_Modules_notification.js.html">Client_Modules_notification.js</a></li>
            
                <li><a href="../classes/Client_Modules_registration.js.html">Client_Modules_registration.js</a></li>
            
                <li><a href="../classes/Client_Sandbox.js.html">Client_Sandbox.js</a></li>
            
                <li><a href="../classes/Server_App_database.js.html">Server_App_database.js</a></li>
            
                <li><a href="../classes/Server_App_Gruntfile.js.html">Server_App_Gruntfile.js</a></li>
            
                <li><a href="../classes/Server_App_middleware.js.html">Server_App_middleware.js</a></li>
            
                <li><a href="../classes/Server_App_Socket.js.html">Server_App_Socket.js</a></li>
            
                <li><a href="../classes/Server_App_Utils.js.html">Server_App_Utils.js</a></li>
            
                <li><a href="../classes/Server_Controller_chatController.js.html">Server_Controller_chatController.js</a></li>
            
                <li><a href="../classes/Server_Controller_profileController.js.html">Server_Controller_profileController.js</a></li>
            
                <li><a href="../classes/Server_Controller_registrationController.js.html">Server_Controller_registrationController.js</a></li>
            
                <li><a href="../classes/Server_Controller_userController.js.html">Server_Controller_userController.js</a></li>
            
                <li><a href="../classes/Server_Model_userModel.js.html">Server_Model_userModel.js</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/App.js.html">App.js</a></li>
            
                <li><a href="../modules/Client_Core.js.html">Client_Core.js</a></li>
            
                <li><a href="../modules/Client_Modules.js.html">Client_Modules.js</a></li>
            
                <li><a href="../modules/Client_Sandbox.js.html">Client_Sandbox.js</a></li>
            
                <li><a href="../modules/Server_App.js.html">Server_App.js</a></li>
            
                <li><a href="../modules/Server_Controller.js.html">Server_Controller.js</a></li>
            
                <li><a href="../modules/Server_Model.js.html">Server_Model.js</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: public\js\libraries\socket.io.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*! Socket.IO.js build:0.9.16, development. Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt; MIT Licensed */

var io = (&#x27;undefined&#x27; === typeof module ? {} : module.exports);
(function() {

    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    (function (exports, global) {

        /**
         * IO namespace.
         *
         * @namespace
         */

        var io = exports;

        /**
         * Socket.IO version
         *
         * @api public
         */

        io.version = &#x27;0.9.16&#x27;;

        /**
         * Protocol implemented.
         *
         * @api public
         */

        io.protocol = 1;

        /**
         * Available transports, these will be populated with the available transports
         *
         * @api public
         */

        io.transports = [];

        /**
         * Keep track of jsonp callbacks.
         *
         * @api private
         */

        io.j = [];

        /**
         * Keep track of our io.Sockets
         *
         * @api private
         */
        io.sockets = {};


        /**
         * Manages connections to hosts.
         *
         * @param {String} uri
         * @Param {Boolean} force creation of new socket (defaults to false)
         * @api public
         */

        io.connect = function (host, details) {
            var uri = io.util.parseUri(host)
                , uuri
                , socket;

            if (global &amp;&amp; global.location) {
                uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);
                uri.host = uri.host || (global.document
                    ? global.document.domain : global.location.hostname);
                uri.port = uri.port || global.location.port;
            }

            uuri = io.util.uniqueUri(uri);

            var options = {
                host: uri.host
                , secure: &#x27;https&#x27; == uri.protocol
                , port: uri.port || (&#x27;https&#x27; == uri.protocol ? 443 : 80)
                , query: uri.query || &#x27;&#x27;
            };

            io.util.merge(options, details);

            if (options[&#x27;force new connection&#x27;] || !io.sockets[uuri]) {
                socket = new io.Socket(options);
            }

            if (!options[&#x27;force new connection&#x27;] &amp;&amp; socket) {
                io.sockets[uuri] = socket;
            }

            socket = socket || io.sockets[uuri];

            // if path is different _id &#x27;&#x27; or /
            return socket.of(uri.path.length &gt; 1 ? uri.path : &#x27;&#x27;);
        };

    })(&#x27;object&#x27; === typeof module ? module.exports : (this.io = {}), this);
    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    (function (exports, global) {

        /**
         * Utilities namespace.
         *
         * @namespace
         */

        var util = exports.util = {};

        /**
         * Parses an URI
         *
         * @author Steven Levithan &lt;stevenlevithan.com&gt; (MIT license)
         * @api public
         */

        var re = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

        var parts = [&#x27;source&#x27;, &#x27;protocol&#x27;, &#x27;authority&#x27;, &#x27;userInfo&#x27;, &#x27;user&#x27;, &#x27;password&#x27;,
            &#x27;host&#x27;, &#x27;port&#x27;, &#x27;relative&#x27;, &#x27;path&#x27;, &#x27;directory&#x27;, &#x27;file&#x27;, &#x27;query&#x27;,
            &#x27;anchor&#x27;];

        util.parseUri = function (str) {
            var m = re.exec(str || &#x27;&#x27;)
                , uri = {}
                , i = 14;

            while (i--) {
                uri[parts[i]] = m[i] || &#x27;&#x27;;
            }

            return uri;
        };

        /**
         * Produces a unique url that identifies a Socket.IO connection.
         *
         * @param {Object} uri
         * @api public
         */

        util.uniqueUri = function (uri) {
            var protocol = uri.protocol
                , host = uri.host
                , port = uri.port;

            if (&#x27;document&#x27; in global) {
                host = host || document.domain;
                port = port || (protocol == &#x27;https&#x27;
                    &amp;&amp; document.location.protocol !== &#x27;https:&#x27; ? 443 : document.location.port);
            } else {
                host = host || &#x27;localhost&#x27;;

                if (!port &amp;&amp; protocol == &#x27;https&#x27;) {
                    port = 443;
                }
            }

            return (protocol || &#x27;http&#x27;) + &#x27;://&#x27; + host + &#x27;:&#x27; + (port || 80);
        };

        /**
         * Mergest 2 query strings in to once unique query string
         *
         * @param {String} base
         * @param {String} addition
         * @api public
         */

        util.query = function (base, addition) {
            var query = util.chunkQuery(base || &#x27;&#x27;)
                , components = [];

            util.merge(query, util.chunkQuery(addition || &#x27;&#x27;));
            for (var part in query) {
                if (query.hasOwnProperty(part)) {
                    components.push(part + &#x27;=&#x27; + query[part]);
                }
            }

            return components.length ? &#x27;?&#x27; + components.join(&#x27;&amp;&#x27;) : &#x27;&#x27;;
        };

        /**
         * Transforms a querystring in to an object
         *
         * @param {String} qs
         * @api public
         */

        util.chunkQuery = function (qs) {
            var query = {}
                , params = qs.split(&#x27;&amp;&#x27;)
                , i = 0
                , l = params.length
                , kv;

            for (; i &lt; l; ++i) {
                kv = params[i].split(&#x27;=&#x27;);
                if (kv[0]) {
                    query[kv[0]] = kv[1];
                }
            }

            return query;
        };

        /**
         * Executes the given function when the page is loaded.
         *
         *     io.util.load(function () { console.log(&#x27;page loaded&#x27;); });
         *
         * @param {Function} fn
         * @api public
         */

        var pageLoaded = false;

        util.load = function (fn) {
            if (&#x27;document&#x27; in global &amp;&amp; document.readyState === &#x27;complete&#x27; || pageLoaded) {
                return fn();
            }

            util.on(global, &#x27;load&#x27;, fn, false);
        };

        /**
         * Adds an event.
         *
         * @api private
         */

        util.on = function (element, event, fn, capture) {
            if (element.attachEvent) {
                element.attachEvent(&#x27;on&#x27; + event, fn);
            } else if (element.addEventListener) {
                element.addEventListener(event, fn, capture);
            }
        };

        /**
         * Generates the correct &#x60;XMLHttpRequest&#x60; for regular and cross domain requests.
         *
         * @param {Boolean} [xdomain] Create a request that can be used cross domain.
         * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.
         * @api private
         */

        util.request = function (xdomain) {

            if (xdomain &amp;&amp; &#x27;undefined&#x27; != typeof XDomainRequest &amp;&amp; !util.ua.hasCORS) {
                return new XDomainRequest();
            }

            if (&#x27;undefined&#x27; != typeof XMLHttpRequest &amp;&amp; (!xdomain || util.ua.hasCORS)) {
                return new XMLHttpRequest();
            }

            if (!xdomain) {
                try {
                    return new window[([&#x27;Active&#x27;].concat(&#x27;Object&#x27;).join(&#x27;X&#x27;))](&#x27;Microsoft.XMLHTTP&#x27;);
                } catch(e) { }
            }

            return null;
        };

        /**
         * XHR based transport constructor.
         *
         * @constructor
         * @api public
         */

        /**
         * Change the internal pageLoaded value.
         */

        if (&#x27;undefined&#x27; != typeof window) {
            util.load(function () {
                pageLoaded = true;
            });
        }

        /**
         * Defers a function to ensure a spinner is not displayed by the browser
         *
         * @param {Function} fn
         * @api public
         */

        util.defer = function (fn) {
            if (!util.ua.webkit || &#x27;undefined&#x27; != typeof importScripts) {
                return fn();
            }

            util.load(function () {
                setTimeout(fn, 100);
            });
        };

        /**
         * Merges two objects.
         *
         * @api public
         */

        util.merge = function merge (target, additional, deep, lastseen) {
            var seen = lastseen || []
                , depth = typeof deep == &#x27;undefined&#x27; ? 2 : deep
                , prop;

            for (prop in additional) {
                if (additional.hasOwnProperty(prop) &amp;&amp; util.indexOf(seen, prop) &lt; 0) {
                    if (typeof target[prop] !== &#x27;object&#x27; || !depth) {
                        target[prop] = additional[prop];
                        seen.push(additional[prop]);
                    } else {
                        util.merge(target[prop], additional[prop], depth - 1, seen);
                    }
                }
            }

            return target;
        };

        /**
         * Merges prototypes _id objects
         *
         * @api public
         */

        util.mixin = function (ctor, ctor2) {
            util.merge(ctor.prototype, ctor2.prototype);
        };

        /**
         * Shortcut for prototypical and static inheritance.
         *
         * @api private
         */

        util.inherit = function (ctor, ctor2) {
            function f() {};
            f.prototype = ctor2.prototype;
            ctor.prototype = new f;
        };

        /**
         * Checks if the given object is an Array.
         *
         *     io.util.isArray([]); // true
         *     io.util.isArray({}); // false
         *
         * @param Object obj
         * @api public
         */

        util.isArray = Array.isArray || function (obj) {
            return Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;;
        };

        /**
         * Intersects values of two arrays into a third
         *
         * @api public
         */

        util.intersect = function (arr, arr2) {
            var ret = []
                , longest = arr.length &gt; arr2.length ? arr : arr2
                , shortest = arr.length &gt; arr2.length ? arr2 : arr;

            for (var i = 0, l = shortest.length; i &lt; l; i++) {
                if (~util.indexOf(longest, shortest[i]))
                    ret.push(shortest[i]);
            }

            return ret;
        };

        /**
         * Array indexOf compatibility.
         *
         * @see bit.ly/a5Dxa2
         * @api public
         */

        util.indexOf = function (arr, o, i) {

            for (var j = arr.length, i = i &lt; 0 ? i + j &lt; 0 ? 0 : i + j : i || 0;
                 i &lt; j &amp;&amp; arr[i] !== o; i++) {}

            return j &lt;= i ? -1 : i;
        };

        /**
         * Converts enumerables to array.
         *
         * @api public
         */

        util.toArray = function (enu) {
            var arr = [];

            for (var i = 0, l = enu.length; i &lt; l; i++)
                arr.push(enu[i]);

            return arr;
        };

        /**
         * UA / engines detection namespace.
         *
         * @namespace
         */

        util.ua = {};

        /**
         * Whether the UA supports CORS for XHR.
         *
         * @api public
         */

        util.ua.hasCORS = &#x27;undefined&#x27; != typeof XMLHttpRequest &amp;&amp; (function () {
            try {
                var a = new XMLHttpRequest();
            } catch (e) {
                return false;
            }

            return a.withCredentials != undefined;
        })();

        /**
         * Detect webkit.
         *
         * @api public
         */

        util.ua.webkit = &#x27;undefined&#x27; != typeof navigator
            &amp;&amp; /webkit/i.test(navigator.userAgent);

        /**
         * Detect iPad/iPhone/iPod.
         *
         * @api public
         */

        util.ua.iDevice = &#x27;undefined&#x27; != typeof navigator
            &amp;&amp; /iPad|iPhone|iPod/i.test(navigator.userAgent);

    })(&#x27;undefined&#x27; != typeof io ? io : module.exports, this);
    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    (function (exports, io) {

        /**
         * Expose constructor.
         */

        exports.EventEmitter = EventEmitter;

        /**
         * Event emitter constructor.
         *
         * @api public.
         */

        function EventEmitter () {};

        /**
         * Adds a listener
         *
         * @api public
         */

        EventEmitter.prototype.on = function (name, fn) {
            if (!this.$events) {
                this.$events = {};
            }

            if (!this.$events[name]) {
                this.$events[name] = fn;
            } else if (io.util.isArray(this.$events[name])) {
                this.$events[name].push(fn);
            } else {
                this.$events[name] = [this.$events[name], fn];
            }

            return this;
        };

        EventEmitter.prototype.addListener = EventEmitter.prototype.on;

        /**
         * Adds a volatile listener.
         *
         * @api public
         */

        EventEmitter.prototype.once = function (name, fn) {
            var self = this;

            function on () {
                self.removeListener(name, on);
                fn.apply(this, arguments);
            };

            on.listener = fn;
            this.on(name, on);

            return this;
        };

        /**
         * Removes a listener.
         *
         * @api public
         */

        EventEmitter.prototype.removeListener = function (name, fn) {
            if (this.$events &amp;&amp; this.$events[name]) {
                var list = this.$events[name];

                if (io.util.isArray(list)) {
                    var pos = -1;

                    for (var i = 0, l = list.length; i &lt; l; i++) {
                        if (list[i] === fn || (list[i].listener &amp;&amp; list[i].listener === fn)) {
                            pos = i;
                            break;
                        }
                    }

                    if (pos &lt; 0) {
                        return this;
                    }

                    list.splice(pos, 1);

                    if (!list.length) {
                        delete this.$events[name];
                    }
                } else if (list === fn || (list.listener &amp;&amp; list.listener === fn)) {
                    delete this.$events[name];
                }
            }

            return this;
        };

        /**
         * Removes all listeners for an event.
         *
         * @api public
         */

        EventEmitter.prototype.removeAllListeners = function (name) {
            if (name === undefined) {
                this.$events = {};
                return this;
            }

            if (this.$events &amp;&amp; this.$events[name]) {
                this.$events[name] = null;
            }

            return this;
        };

        /**
         * Gets all listeners for a certain event.
         *
         * @api publci
         */

        EventEmitter.prototype.listeners = function (name) {
            if (!this.$events) {
                this.$events = {};
            }

            if (!this.$events[name]) {
                this.$events[name] = [];
            }

            if (!io.util.isArray(this.$events[name])) {
                this.$events[name] = [this.$events[name]];
            }

            return this.$events[name];
        };

        /**
         * Emits an event.
         *
         * @api public
         */

        EventEmitter.prototype.emit = function (name) {
            if (!this.$events) {
                return false;
            }

            var handler = this.$events[name];

            if (!handler) {
                return false;
            }

            var args = Array.prototype.slice.call(arguments, 1);

            if (&#x27;function&#x27; == typeof handler) {
                handler.apply(this, args);
            } else if (io.util.isArray(handler)) {
                var listeners = handler.slice();

                for (var i = 0, l = listeners.length; i &lt; l; i++) {
                    listeners[i].apply(this, args);
                }
            } else {
                return false;
            }

            return true;
        };

    })(
            &#x27;undefined&#x27; != typeof io ? io : module.exports
            , &#x27;undefined&#x27; != typeof io ? io : module.parent.exports
        );

    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    /**
     * Based on JSON2 (http://www.JSON.org/js.html).
     */

    (function (exports, nativeJSON) {
        &quot;use strict&quot;;

        // use native JSON if it&#x27;s available
        if (nativeJSON &amp;&amp; nativeJSON.parse){
            return exports.JSON = {
                parse: nativeJSON.parse
                , stringify: nativeJSON.stringify
            };
        }

        var JSON = exports.JSON = {};

        function f(n) {
            // Format integers to have at least two digits.
            return n &lt; 10 ? &#x27;0&#x27; + n : n;
        }

        function date(d, key) {
            return isFinite(d.valueOf()) ?
                d.getUTCFullYear()     + &#x27;-&#x27; +
                    f(d.getUTCMonth() + 1) + &#x27;-&#x27; +
                    f(d.getUTCDate())      + &#x27;T&#x27; +
                    f(d.getUTCHours())     + &#x27;:&#x27; +
                    f(d.getUTCMinutes())   + &#x27;:&#x27; +
                    f(d.getUTCSeconds())   + &#x27;Z&#x27; : null;
        };

        var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
            escapable = /[\\\&quot;\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
            gap,
            indent,
            meta = {    // table of character substitutions
                &#x27;\b&#x27;: &#x27;\\b&#x27;,
                &#x27;\t&#x27;: &#x27;\\t&#x27;,
                &#x27;\n&#x27;: &#x27;\\n&#x27;,
                &#x27;\f&#x27;: &#x27;\\f&#x27;,
                &#x27;\r&#x27;: &#x27;\\r&#x27;,
                &#x27;&quot;&#x27; : &#x27;\\&quot;&#x27;,
                &#x27;\\&#x27;: &#x27;\\\\&#x27;
            },
            rep;


        function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

            escapable.lastIndex = 0;
            return escapable.test(string) ? &#x27;&quot;&#x27; + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === &#x27;string&#x27; ? c :
                    &#x27;\\u&#x27; + (&#x27;0000&#x27; + a.charCodeAt(0).toString(16)).slice(-4);
            }) + &#x27;&quot;&#x27; : &#x27;&quot;&#x27; + string + &#x27;&quot;&#x27;;
        }


        function str(key, holder) {

// Produce a string _id holder[key].

            var i,          // The loop counter.
                k,          // The member key.
                v,          // The member value.
                length,
                mind = gap,
                partial,
                value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

            if (value instanceof Date) {
                value = date(key);
            }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

            if (typeof rep === &#x27;function&#x27;) {
                value = rep.call(holder, key, value);
            }

// What happens next depends on the value&#x27;s type.

            switch (typeof value) {
                case &#x27;string&#x27;:
                    return quote(value);

                case &#x27;number&#x27;:

// JSON numbers must be finite. Encode non-finite numbers as null.

                    return isFinite(value) ? String(value) : &#x27;null&#x27;;

                case &#x27;boolean&#x27;:
                case &#x27;null&#x27;:

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce &#x27;null&#x27;. The case is included here in
// the remote chance that this gets fixed someday.

                    return String(value);

// If the type is &#x27;object&#x27;, we might be dealing with an object or an array or
// null.

                case &#x27;object&#x27;:

// Due to a specification blunder in ECMAScript, typeof null is &#x27;object&#x27;,
// so watch out for that case.

                    if (!value) {
                        return &#x27;null&#x27;;
                    }

// Make an array to hold the partial results of stringifying this object value.

                    gap += indent;
                    partial = [];

// Is the value an array?

                    if (Object.prototype.toString.apply(value) === &#x27;[object Array]&#x27;) {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                        length = value.length;
                        for (i = 0; i &lt; length; i += 1) {
                            partial[i] = str(i, value) || &#x27;null&#x27;;
                        }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                        v = partial.length === 0 ? &#x27;[]&#x27; : gap ?
                            &#x27;[\n&#x27; + gap + partial.join(&#x27;,\n&#x27; + gap) + &#x27;\n&#x27; + mind + &#x27;]&#x27; :
                            &#x27;[&#x27; + partial.join(&#x27;,&#x27;) + &#x27;]&#x27;;
                        gap = mind;
                        return v;
                    }

// If the replacer is an array, use it to select the members to be stringified.

                    if (rep &amp;&amp; typeof rep === &#x27;object&#x27;) {
                        length = rep.length;
                        for (i = 0; i &lt; length; i += 1) {
                            if (typeof rep[i] === &#x27;string&#x27;) {
                                k = rep[i];
                                v = str(k, value);
                                if (v) {
                                    partial.push(quote(k) + (gap ? &#x27;: &#x27; : &#x27;:&#x27;) + v);
                                }
                            }
                        }
                    } else {

// Otherwise, iterate through all of the keys in the object.

                        for (k in value) {
                            if (Object.prototype.hasOwnProperty.call(value, k)) {
                                v = str(k, value);
                                if (v) {
                                    partial.push(quote(k) + (gap ? &#x27;: &#x27; : &#x27;:&#x27;) + v);
                                }
                            }
                        }
                    }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

                    v = partial.length === 0 ? &#x27;{}&#x27; : gap ?
                        &#x27;{\n&#x27; + gap + partial.join(&#x27;,\n&#x27; + gap) + &#x27;\n&#x27; + mind + &#x27;}&#x27; :
                        &#x27;{&#x27; + partial.join(&#x27;,&#x27;) + &#x27;}&#x27;;
                    gap = mind;
                    return v;
            }
        }

// If the JSON object does not yet have a stringify method, give it one.

        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = &#x27;&#x27;;
            indent = &#x27;&#x27;;

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === &#x27;number&#x27;) {
                for (i = 0; i &lt; space; i += 1) {
                    indent += &#x27; &#x27;;
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === &#x27;string&#x27;) {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer &amp;&amp; typeof replacer !== &#x27;function&#x27; &amp;&amp;
                (typeof replacer !== &#x27;object&#x27; ||
                    typeof replacer.length !== &#x27;number&#x27;)) {
                throw new Error(&#x27;JSON.stringify&#x27;);
            }

// Make a fake root object containing our value under the key of &#x27;&#x27;.
// Return the result of stringifying the value.

            return str(&#x27;&#x27;, {&#x27;&#x27;: value});
        };

// If the JSON object does not yet have a parse method, give it one.

        JSON.parse = function (text, reviver) {
            // The parse method takes a text and an optional reviver function, and returns
            // a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

                // The walk method is used to recursively walk the resulting structure so
                // that modifications can be made.

                var k, v, value = holder[key];
                if (value &amp;&amp; typeof value === &#x27;object&#x27;) {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


            // Parsing happens in four stages. In the first stage, we replace certain
            // Unicode characters with escape sequences. JavaScript handles many characters
            // incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return &#x27;\\u&#x27; +
                        (&#x27;0000&#x27; + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

            // In the second stage, we run the text against regular expressions that look
            // for non-JSON patterns. We are especially concerned with &#x27;()&#x27; and &#x27;new&#x27;
            // because they can cause invocation, and &#x27;=&#x27; because it can cause mutation.
            // But just to be safe, we want to reject all unexpected forms.

            // We split the second stage into 4 regexp operations in order to work around
            // crippling inefficiencies in IE&#x27;s and Safari&#x27;s regexp engines. First we
            // replace the JSON backslash pairs with &#x27;@&#x27; (a non-JSON character). Second, we
            // replace all simple value tokens with &#x27;]&#x27; characters. Third, we delete all
            // open brackets that follow a colon or comma or that begin the text. Finally,
            // we look to see that the remaining characters are only whitespace or &#x27;]&#x27; or
            // &#x27;,&#x27; or &#x27;:&#x27; or &#x27;{&#x27; or &#x27;}&#x27;. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                .test(text.replace(/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]{4})/g, &#x27;@&#x27;)
                    .replace(/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, &#x27;]&#x27;)
                    .replace(/(?:^|:|,)(?:\s*\[)+/g, &#x27;&#x27;))) {

                // In the third stage we use the eval function to compile the text into a
                // JavaScript structure. The &#x27;{&#x27; operator is subject to a syntactic ambiguity
                // in JavaScript: it can begin a block or an object literal. We wrap the text
                // in parens to eliminate the ambiguity.

                j = eval(&#x27;(&#x27; + text + &#x27;)&#x27;);

                // In the optional fourth stage, we recursively walk the new structure, passing
                // each name/value pair to a reviver function for possible transformation.

                return typeof reviver === &#x27;function&#x27; ?
                    walk({&#x27;&#x27;: j}, &#x27;&#x27;) : j;
            }

            // If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError(&#x27;JSON.parse&#x27;);
        };

    })(
            &#x27;undefined&#x27; != typeof io ? io : module.exports
            , typeof JSON !== &#x27;undefined&#x27; ? JSON : undefined
        );

    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    (function (exports, io) {

        /**
         * Parser namespace.
         *
         * @namespace
         */

        var parser = exports.parser = {};

        /**
         * Packet types.
         */

        var packets = parser.packets = [
            &#x27;disconnect&#x27;
            , &#x27;connect&#x27;
            , &#x27;heartbeat&#x27;
            , &#x27;message&#x27;
            , &#x27;json&#x27;
            , &#x27;event&#x27;
            , &#x27;ack&#x27;
            , &#x27;error&#x27;
            , &#x27;noop&#x27;
        ];

        /**
         * Errors reasons.
         */

        var reasons = parser.reasons = [
            &#x27;transport not supported&#x27;
            , &#x27;client not handshaken&#x27;
            , &#x27;unauthorized&#x27;
        ];

        /**
         * Errors advice.
         */

        var advice = parser.advice = [
            &#x27;reconnect&#x27;
        ];

        /**
         * Shortcuts.
         */

        var JSON = io.JSON
            , indexOf = io.util.indexOf;

        /**
         * Encodes a packet.
         *
         * @api private
         */

        parser.encodePacket = function (packet) {
            var type = indexOf(packets, packet.type)
                , id = packet.id || &#x27;&#x27;
                , endpoint = packet.endpoint || &#x27;&#x27;
                , ack = packet.ack
                , data = null;

            switch (packet.type) {
                case &#x27;error&#x27;:
                    var reason = packet.reason ? indexOf(reasons, packet.reason) : &#x27;&#x27;
                        , adv = packet.advice ? indexOf(advice, packet.advice) : &#x27;&#x27;;

                    if (reason !== &#x27;&#x27; || adv !== &#x27;&#x27;)
                        data = reason + (adv !== &#x27;&#x27; ? (&#x27;+&#x27; + adv) : &#x27;&#x27;);

                    break;

                case &#x27;message&#x27;:
                    if (packet.data !== &#x27;&#x27;)
                        data = packet.data;
                    break;

                case &#x27;event&#x27;:
                    var ev = { name: packet.name };

                    if (packet.args &amp;&amp; packet.args.length) {
                        ev.args = packet.args;
                    }

                    data = JSON.stringify(ev);
                    break;

                case &#x27;json&#x27;:
                    data = JSON.stringify(packet.data);
                    break;

                case &#x27;connect&#x27;:
                    if (packet.qs)
                        data = packet.qs;
                    break;

                case &#x27;ack&#x27;:
                    data = packet.ackId
                        + (packet.args &amp;&amp; packet.args.length
                        ? &#x27;+&#x27; + JSON.stringify(packet.args) : &#x27;&#x27;);
                    break;
            }

            // construct packet with required fragments
            var encoded = [
                type
                , id + (ack == &#x27;data&#x27; ? &#x27;+&#x27; : &#x27;&#x27;)
                , endpoint
            ];

            // data fragment is optional
            if (data !== null &amp;&amp; data !== undefined)
                encoded.push(data);

            return encoded.join(&#x27;:&#x27;);
        };

        /**
         * Encodes multiple messages (payload).
         *
         * @param {Array} messages
         * @api private
         */

        parser.encodePayload = function (packets) {
            var decoded = &#x27;&#x27;;

            if (packets.length == 1)
                return packets[0];

            for (var i = 0, l = packets.length; i &lt; l; i++) {
                var packet = packets[i];
                decoded += &#x27;\ufffd&#x27; + packet.length + &#x27;\ufffd&#x27; + packets[i];
            }

            return decoded;
        };

        /**
         * Decodes a packet
         *
         * @api private
         */

        var regexp = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;

        parser.decodePacket = function (data) {
            var pieces = data.match(regexp);

            if (!pieces) return {};

            var id = pieces[2] || &#x27;&#x27;
                , data = pieces[5] || &#x27;&#x27;
                , packet = {
                    type: packets[pieces[1]]
                    , endpoint: pieces[4] || &#x27;&#x27;
                };

            // whether we need to acknowledge the packet
            if (id) {
                packet.id = id;
                if (pieces[3])
                    packet.ack = &#x27;data&#x27;;
                else
                    packet.ack = true;
            }

            // handle different packet types
            switch (packet.type) {
                case &#x27;error&#x27;:
                    var pieces = data.split(&#x27;+&#x27;);
                    packet.reason = reasons[pieces[0]] || &#x27;&#x27;;
                    packet.advice = advice[pieces[1]] || &#x27;&#x27;;
                    break;

                case &#x27;message&#x27;:
                    packet.data = data || &#x27;&#x27;;
                    break;

                case &#x27;event&#x27;:
                    try {
                        var opts = JSON.parse(data);
                        packet.name = opts.name;
                        packet.args = opts.args;
                    } catch (e) { }

                    packet.args = packet.args || [];
                    break;

                case &#x27;json&#x27;:
                    try {
                        packet.data = JSON.parse(data);
                    } catch (e) { }
                    break;

                case &#x27;connect&#x27;:
                    packet.qs = data || &#x27;&#x27;;
                    break;

                case &#x27;ack&#x27;:
                    var pieces = data.match(/^([0-9]+)(\+)?(.*)/);
                    if (pieces) {
                        packet.ackId = pieces[1];
                        packet.args = [];

                        if (pieces[3]) {
                            try {
                                packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];
                            } catch (e) { }
                        }
                    }
                    break;

                case &#x27;disconnect&#x27;:
                case &#x27;heartbeat&#x27;:
                    break;
            };

            return packet;
        };

        /**
         * Decodes data payload. Detects multiple messages
         *
         * @return {Array} messages
         * @api public
         */

        parser.decodePayload = function (data) {
            // IE doesn&#x27;t like data[i] for unicode chars, charAt works fine
            if (data.charAt(0) == &#x27;\ufffd&#x27;) {
                var ret = [];

                for (var i = 1, length = &#x27;&#x27;; i &lt; data.length; i++) {
                    if (data.charAt(i) == &#x27;\ufffd&#x27;) {
                        ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));
                        i += Number(length) + 1;
                        length = &#x27;&#x27;;
                    } else {
                        length += data.charAt(i);
                    }
                }

                return ret;
            } else {
                return [parser.decodePacket(data)];
            }
        };

    })(
            &#x27;undefined&#x27; != typeof io ? io : module.exports
            , &#x27;undefined&#x27; != typeof io ? io : module.parent.exports
        );
    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    (function (exports, io) {

        /**
         * Expose constructor.
         */

        exports.Transport = Transport;

        /**
         * This is the transport template for all supported transport methods.
         *
         * @constructor
         * @api public
         */

        function Transport (socket, sessid) {
            this.socket = socket;
            this.sessid = sessid;
        };

        /**
         * Apply EventEmitter mixin.
         */

        io.util.mixin(Transport, io.EventEmitter);


        /**
         * Indicates whether heartbeats is enabled for this transport
         *
         * @api private
         */

        Transport.prototype.heartbeats = function () {
            return true;
        };

        /**
         * Handles the response _id the server. When a new response is received
         * it will automatically update the timeout, decode the message and
         * forwards the response to the onMessage function for further processing.
         *
         * @param {String} data Response _id the server.
         * @api private
         */

        Transport.prototype.onData = function (data) {
            this.clearCloseTimeout();

            // If the connection in currently open (or in a reopening state) reset the close
            // timeout since we have just received data. This check is necessary so
            // that we don&#x27;t reset the timeout on an explicitly disconnected connection.
            if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {
                this.setCloseTimeout();
            }

            if (data !== &#x27;&#x27;) {
                // todo: we should only do decodePayload for xhr transports
                var msgs = io.parser.decodePayload(data);

                if (msgs &amp;&amp; msgs.length) {
                    for (var i = 0, l = msgs.length; i &lt; l; i++) {
                        this.onPacket(msgs[i]);
                    }
                }
            }

            return this;
        };

        /**
         * Handles packets.
         *
         * @api private
         */

        Transport.prototype.onPacket = function (packet) {
            this.socket.setHeartbeatTimeout();

            if (packet.type == &#x27;heartbeat&#x27;) {
                return this.onHeartbeat();
            }

            if (packet.type == &#x27;connect&#x27; &amp;&amp; packet.endpoint == &#x27;&#x27;) {
                this.onConnect();
            }

            if (packet.type == &#x27;error&#x27; &amp;&amp; packet.advice == &#x27;reconnect&#x27;) {
                this.isOpen = false;
            }

            this.socket.onPacket(packet);

            return this;
        };

        /**
         * Sets close timeout
         *
         * @api private
         */

        Transport.prototype.setCloseTimeout = function () {
            if (!this.closeTimeout) {
                var self = this;

                this.closeTimeout = setTimeout(function () {
                    self.onDisconnect();
                }, this.socket.closeTimeout);
            }
        };

        /**
         * Called when transport disconnects.
         *
         * @api private
         */

        Transport.prototype.onDisconnect = function () {
            if (this.isOpen) this.close();
            this.clearTimeouts();
            this.socket.onDisconnect();
            return this;
        };

        /**
         * Called when transport connects
         *
         * @api private
         */

        Transport.prototype.onConnect = function () {
            this.socket.onConnect();
            return this;
        };

        /**
         * Clears close timeout
         *
         * @api private
         */

        Transport.prototype.clearCloseTimeout = function () {
            if (this.closeTimeout) {
                clearTimeout(this.closeTimeout);
                this.closeTimeout = null;
            }
        };

        /**
         * Clear timeouts
         *
         * @api private
         */

        Transport.prototype.clearTimeouts = function () {
            this.clearCloseTimeout();

            if (this.reopenTimeout) {
                clearTimeout(this.reopenTimeout);
            }
        };

        /**
         * Sends a packet
         *
         * @param {Object} packet object.
         * @api private
         */

        Transport.prototype.packet = function (packet) {
            this.send(io.parser.encodePacket(packet));
        };

        /**
         * Send the received heartbeat message back to server. So the server
         * knows we are still connected.
         *
         * @param {String} heartbeat Heartbeat response _id the server.
         * @api private
         */

        Transport.prototype.onHeartbeat = function (heartbeat) {
            this.packet({ type: &#x27;heartbeat&#x27; });
        };

        /**
         * Called when the transport opens.
         *
         * @api private
         */

        Transport.prototype.onOpen = function () {
            this.isOpen = true;
            this.clearCloseTimeout();
            this.socket.onOpen();
        };

        /**
         * Notifies the base when the connection with the Socket.IO server
         * has been disconnected.
         *
         * @api private
         */

        Transport.prototype.onClose = function () {
            var self = this;

            /* FIXME: reopen delay causing a infinit loop
             this.reopenTimeout = setTimeout(function () {
             self.open();
             }, this.socket.options[&#x27;reopen delay&#x27;]);*/

            this.isOpen = false;
            this.socket.onClose();
            this.onDisconnect();
        };

        /**
         * Generates a connection url based on the Socket.IO URL Protocol.
         * See &lt;https://github.com/learnboost/socket.io-node/&gt; for more details.
         *
         * @returns {String} Connection url
         * @api private
         */

        Transport.prototype.prepareUrl = function () {
            var options = this.socket.options;

            return this.scheme() + &#x27;://&#x27;
                + options.host + &#x27;:&#x27; + options.port + &#x27;/&#x27;
                + options.resource + &#x27;/&#x27; + io.protocol
                + &#x27;/&#x27; + this.name + &#x27;/&#x27; + this.sessid;
        };

        /**
         * Checks if the transport is ready to start a connection.
         *
         * @param {Socket} socket The socket instance that needs a transport
         * @param {Function} fn The callback
         * @api private
         */

        Transport.prototype.ready = function (socket, fn) {
            fn.call(this);
        };
    })(
            &#x27;undefined&#x27; != typeof io ? io : module.exports
            , &#x27;undefined&#x27; != typeof io ? io : module.parent.exports
        );
    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    (function (exports, io, global) {

        /**
         * Expose constructor.
         */

        exports.Socket = Socket;

        /**
         * Create a new &#x60;Socket.IO client&#x60; which can establish a persistent
         * connection with a Socket.IO enabled server.
         *
         * @api public
         */

        function Socket (options) {
            this.options = {
                port: 80
                , secure: false
                , document: &#x27;document&#x27; in global ? document : false
                , resource: &#x27;socket.io&#x27;
                , transports: io.transports
                , &#x27;connect timeout&#x27;: 10000
                , &#x27;try multiple transports&#x27;: true
                , &#x27;reconnect&#x27;: true
                , &#x27;reconnection delay&#x27;: 500
                , &#x27;reconnection limit&#x27;: Infinity
                , &#x27;reopen delay&#x27;: 3000
                , &#x27;max reconnection attempts&#x27;: 10
                , &#x27;sync disconnect on unload&#x27;: false
                , &#x27;auto connect&#x27;: true
                , &#x27;flash policy port&#x27;: 10843
                , &#x27;manualFlush&#x27;: false
            };

            io.util.merge(this.options, options);

            this.connected = false;
            this.open = false;
            this.connecting = false;
            this.reconnecting = false;
            this.namespaces = {};
            this.buffer = [];
            this.doBuffer = false;

            if (this.options[&#x27;sync disconnect on unload&#x27;] &amp;&amp;
                (!this.isXDomain() || io.util.ua.hasCORS)) {
                var self = this;
                io.util.on(global, &#x27;beforeunload&#x27;, function () {
                    self.disconnectSync();
                }, false);
            }

            if (this.options[&#x27;auto connect&#x27;]) {
                this.connect();
            }
        };

        /**
         * Apply EventEmitter mixin.
         */

        io.util.mixin(Socket, io.EventEmitter);

        /**
         * Returns a namespace listener/emitter for this socket
         *
         * @api public
         */

        Socket.prototype.of = function (name) {
            if (!this.namespaces[name]) {
                this.namespaces[name] = new io.SocketNamespace(this, name);

                if (name !== &#x27;&#x27;) {
                    this.namespaces[name].packet({ type: &#x27;connect&#x27; });
                }
            }

            return this.namespaces[name];
        };

        /**
         * Emits the given event to the Socket and all namespaces
         *
         * @api private
         */

        Socket.prototype.publish = function () {
            this.emit.apply(this, arguments);

            var nsp;

            for (var i in this.namespaces) {
                if (this.namespaces.hasOwnProperty(i)) {
                    nsp = this.of(i);
                    nsp.$emit.apply(nsp, arguments);
                }
            }
        };

        /**
         * Performs the handshake
         *
         * @api private
         */

        function empty () { };

        Socket.prototype.handshake = function (fn) {
            var self = this
                , options = this.options;

            function complete (data) {
                if (data instanceof Error) {
                    self.connecting = false;
                    self.onError(data.message);
                } else {
                    fn.apply(null, data.split(&#x27;:&#x27;));
                }
            };

            var url = [
                &#x27;http&#x27; + (options.secure ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;:/&#x27;
                , options.host + &#x27;:&#x27; + options.port
                , options.resource
                , io.protocol
                , io.util.query(this.options.query, &#x27;t=&#x27; + +new Date)
            ].join(&#x27;/&#x27;);

            if (this.isXDomain() &amp;&amp; !io.util.ua.hasCORS) {
                var insertAt = document.getElementsByTagName(&#x27;script&#x27;)[0]
                    , script = document.createElement(&#x27;script&#x27;);

                script.src = url + &#x27;&amp;jsonp=&#x27; + io.j.length;
                insertAt.parentNode.insertBefore(script, insertAt);

                io.j.push(function (data) {
                    complete(data);
                    script.parentNode.removeChild(script);
                });
            } else {
                var xhr = io.util.request();

                xhr.open(&#x27;GET&#x27;, url, true);
                if (this.isXDomain()) {
                    xhr.withCredentials = true;
                }
                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 4) {
                        xhr.onreadystatechange = empty;

                        if (xhr.status == 200) {
                            complete(xhr.responseText);
                        } else if (xhr.status == 403) {
                            self.onError(xhr.responseText);
                        } else {
                            self.connecting = false;
                            !self.reconnecting &amp;&amp; self.onError(xhr.responseText);
                        }
                    }
                };
                xhr.send(null);
            }
        };

        /**
         * Find an available transport based on the options supplied in the constructor.
         *
         * @api private
         */

        Socket.prototype.getTransport = function (override) {
            var transports = override || this.transports, match;

            for (var i = 0, transport; transport = transports[i]; i++) {
                if (io.Transport[transport]
                    &amp;&amp; io.Transport[transport].check(this)
                    &amp;&amp; (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {
                    return new io.Transport[transport](this, this.sessionid);
                }
            }

            return null;
        };

        /**
         * Connects to the server.
         *
         * @param {Function} [fn] Callback.
         * @returns {io.Socket}
         * @api public
         */

        Socket.prototype.connect = function (fn) {
            if (this.connecting) {
                return this;
            }

            var self = this;
            self.connecting = true;

            this.handshake(function (sid, heartbeat, close, transports) {
                self.sessionid = sid;
                self.closeTimeout = close * 1000;
                self.heartbeatTimeout = heartbeat * 1000;
                if(!self.transports)
                    self.transports = self.origTransports = (transports ? io.util.intersect(
                        transports.split(&#x27;,&#x27;)
                        , self.options.transports
                    ) : self.options.transports);

                self.setHeartbeatTimeout();

                function connect (transports){
                    if (self.transport) self.transport.clearTimeouts();

                    self.transport = self.getTransport(transports);
                    if (!self.transport) return self.publish(&#x27;connect_failed&#x27;);

                    // once the transport is ready
                    self.transport.ready(self, function () {
                        self.connecting = true;
                        self.publish(&#x27;connecting&#x27;, self.transport.name);
                        self.transport.open();

                        if (self.options[&#x27;connect timeout&#x27;]) {
                            self.connectTimeoutTimer = setTimeout(function () {
                                if (!self.connected) {
                                    self.connecting = false;

                                    if (self.options[&#x27;try multiple transports&#x27;]) {
                                        var remaining = self.transports;

                                        while (remaining.length &gt; 0 &amp;&amp; remaining.splice(0,1)[0] !=
                                            self.transport.name) {}

                                        if (remaining.length){
                                            connect(remaining);
                                        } else {
                                            self.publish(&#x27;connect_failed&#x27;);
                                        }
                                    }
                                }
                            }, self.options[&#x27;connect timeout&#x27;]);
                        }
                    });
                }

                connect(self.transports);

                self.once(&#x27;connect&#x27;, function (){
                    clearTimeout(self.connectTimeoutTimer);

                    fn &amp;&amp; typeof fn == &#x27;function&#x27; &amp;&amp; fn();
                });
            });

            return this;
        };

        /**
         * Clears and sets a new heartbeat timeout using the value given by the
         * server during the handshake.
         *
         * @api private
         */

        Socket.prototype.setHeartbeatTimeout = function () {
            clearTimeout(this.heartbeatTimeoutTimer);
            if(this.transport &amp;&amp; !this.transport.heartbeats()) return;

            var self = this;
            this.heartbeatTimeoutTimer = setTimeout(function () {
                self.transport.onClose();
            }, this.heartbeatTimeout);
        };

        /**
         * Sends a message.
         *
         * @param {Object} data packet.
         * @returns {io.Socket}
         * @api public
         */

        Socket.prototype.packet = function (data) {
            if (this.connected &amp;&amp; !this.doBuffer) {
                this.transport.packet(data);
            } else {
                this.buffer.push(data);
            }

            return this;
        };

        /**
         * Sets buffer state
         *
         * @api private
         */

        Socket.prototype.setBuffer = function (v) {
            this.doBuffer = v;

            if (!v &amp;&amp; this.connected &amp;&amp; this.buffer.length) {
                if (!this.options[&#x27;manualFlush&#x27;]) {
                    this.flushBuffer();
                }
            }
        };

        /**
         * Flushes the buffer data over the wire.
         * To be invoked manually when &#x27;manualFlush&#x27; is set to true.
         *
         * @api public
         */

        Socket.prototype.flushBuffer = function() {
            this.transport.payload(this.buffer);
            this.buffer = [];
        };


        /**
         * Disconnect the established connect.
         *
         * @returns {io.Socket}
         * @api public
         */

        Socket.prototype.disconnect = function () {
            if (this.connected || this.connecting) {
                if (this.open) {
                    this.of(&#x27;&#x27;).packet({ type: &#x27;disconnect&#x27; });
                }

                // handle disconnection immediately
                this.onDisconnect(&#x27;booted&#x27;);
            }

            return this;
        };

        /**
         * Disconnects the socket with a sync XHR.
         *
         * @api private
         */

        Socket.prototype.disconnectSync = function () {
            // ensure disconnection
            var xhr = io.util.request();
            var uri = [
                &#x27;http&#x27; + (this.options.secure ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;:/&#x27;
                , this.options.host + &#x27;:&#x27; + this.options.port
                , this.options.resource
                , io.protocol
                , &#x27;&#x27;
                , this.sessionid
            ].join(&#x27;/&#x27;) + &#x27;/?disconnect=1&#x27;;

            xhr.open(&#x27;GET&#x27;, uri, false);
            xhr.send(null);

            // handle disconnection immediately
            this.onDisconnect(&#x27;booted&#x27;);
        };

        /**
         * Check if we need to use cross domain enabled transports. Cross domain would
         * be a different port or different domain name.
         *
         * @returns {Boolean}
         * @api private
         */

        Socket.prototype.isXDomain = function () {

            var port = global.location.port ||
                (&#x27;https:&#x27; == global.location.protocol ? 443 : 80);

            return this.options.host !== global.location.hostname
                || this.options.port != port;
        };

        /**
         * Called upon handshake.
         *
         * @api private
         */

        Socket.prototype.onConnect = function () {
            if (!this.connected) {
                this.connected = true;
                this.connecting = false;
                if (!this.doBuffer) {
                    // make sure to flush the buffer
                    this.setBuffer(false);
                }
                this.emit(&#x27;connect&#x27;);
            }
        };

        /**
         * Called when the transport opens
         *
         * @api private
         */

        Socket.prototype.onOpen = function () {
            this.open = true;
        };

        /**
         * Called when the transport closes.
         *
         * @api private
         */

        Socket.prototype.onClose = function () {
            this.open = false;
            clearTimeout(this.heartbeatTimeoutTimer);
        };

        /**
         * Called when the transport first opens a connection
         *
         * @param text
         */

        Socket.prototype.onPacket = function (packet) {
            this.of(packet.endpoint).onPacket(packet);
        };

        /**
         * Handles an error.
         *
         * @api private
         */

        Socket.prototype.onError = function (err) {
            if (err &amp;&amp; err.advice) {
                if (err.advice === &#x27;reconnect&#x27; &amp;&amp; (this.connected || this.connecting)) {
                    this.disconnect();
                    if (this.options.reconnect) {
                        this.reconnect();
                    }
                }
            }

            this.publish(&#x27;error&#x27;, err &amp;&amp; err.reason ? err.reason : err);
        };

        /**
         * Called when the transport disconnects.
         *
         * @api private
         */

        Socket.prototype.onDisconnect = function (reason) {
            var wasConnected = this.connected
                , wasConnecting = this.connecting;

            this.connected = false;
            this.connecting = false;
            this.open = false;

            if (wasConnected || wasConnecting) {
                this.transport.close();
                this.transport.clearTimeouts();
                if (wasConnected) {
                    this.publish(&#x27;disconnect&#x27;, reason);

                    if (&#x27;booted&#x27; != reason &amp;&amp; this.options.reconnect &amp;&amp; !this.reconnecting) {
                        this.reconnect();
                    }
                }
            }
        };

        /**
         * Called upon reconnection.
         *
         * @api private
         */

        Socket.prototype.reconnect = function () {
            this.reconnecting = true;
            this.reconnectionAttempts = 0;
            this.reconnectionDelay = this.options[&#x27;reconnection delay&#x27;];

            var self = this
                , maxAttempts = this.options[&#x27;max reconnection attempts&#x27;]
                , tryMultiple = this.options[&#x27;try multiple transports&#x27;]
                , limit = this.options[&#x27;reconnection limit&#x27;];

            function reset () {
                if (self.connected) {
                    for (var i in self.namespaces) {
                        if (self.namespaces.hasOwnProperty(i) &amp;&amp; &#x27;&#x27; !== i) {
                            self.namespaces[i].packet({ type: &#x27;connect&#x27; });
                        }
                    }
                    self.publish(&#x27;reconnect&#x27;, self.transport.name, self.reconnectionAttempts);
                }

                clearTimeout(self.reconnectionTimer);

                self.removeListener(&#x27;connect_failed&#x27;, maybeReconnect);
                self.removeListener(&#x27;connect&#x27;, maybeReconnect);

                self.reconnecting = false;

                delete self.reconnectionAttempts;
                delete self.reconnectionDelay;
                delete self.reconnectionTimer;
                delete self.redoTransports;

                self.options[&#x27;try multiple transports&#x27;] = tryMultiple;
            };

            function maybeReconnect () {
                if (!self.reconnecting) {
                    return;
                }

                if (self.connected) {
                    return reset();
                };

                if (self.connecting &amp;&amp; self.reconnecting) {
                    return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);
                }

                if (self.reconnectionAttempts++ &gt;= maxAttempts) {
                    if (!self.redoTransports) {
                        self.on(&#x27;connect_failed&#x27;, maybeReconnect);
                        self.options[&#x27;try multiple transports&#x27;] = true;
                        self.transports = self.origTransports;
                        self.transport = self.getTransport();
                        self.redoTransports = true;
                        self.connect();
                    } else {
                        self.publish(&#x27;reconnect_failed&#x27;);
                        reset();
                    }
                } else {
                    if (self.reconnectionDelay &lt; limit) {
                        self.reconnectionDelay *= 2; // exponential back off
                    }

                    self.connect();
                    self.publish(&#x27;reconnecting&#x27;, self.reconnectionDelay, self.reconnectionAttempts);
                    self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);
                }
            };

            this.options[&#x27;try multiple transports&#x27;] = false;
            this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);

            this.on(&#x27;connect&#x27;, maybeReconnect);
        };

    })(
            &#x27;undefined&#x27; != typeof io ? io : module.exports
            , &#x27;undefined&#x27; != typeof io ? io : module.parent.exports
            , this
        );
    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    (function (exports, io) {

        /**
         * Expose constructor.
         */

        exports.SocketNamespace = SocketNamespace;

        /**
         * Socket namespace constructor.
         *
         * @constructor
         * @api public
         */

        function SocketNamespace (socket, name) {
            this.socket = socket;
            this.name = name || &#x27;&#x27;;
            this.flags = {};
            this.json = new Flag(this, &#x27;json&#x27;);
            this.ackPackets = 0;
            this.acks = {};
        };

        /**
         * Apply EventEmitter mixin.
         */

        io.util.mixin(SocketNamespace, io.EventEmitter);

        /**
         * Copies emit since we override it
         *
         * @api private
         */

        SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;

        /**
         * Creates a new namespace, by proxying the request to the socket. This
         * allows us to use the synax as we do on the server.
         *
         * @api public
         */

        SocketNamespace.prototype.of = function () {
            return this.socket.of.apply(this.socket, arguments);
        };

        /**
         * Sends a packet.
         *
         * @api private
         */

        SocketNamespace.prototype.packet = function (packet) {
            packet.endpoint = this.name;
            this.socket.packet(packet);
            this.flags = {};
            return this;
        };

        /**
         * Sends a message
         *
         * @api public
         */

        SocketNamespace.prototype.send = function (data, fn) {
            var packet = {
                type: this.flags.json ? &#x27;json&#x27; : &#x27;message&#x27;
                , data: data
            };

            if (&#x27;function&#x27; == typeof fn) {
                packet.id = ++this.ackPackets;
                packet.ack = true;
                this.acks[packet.id] = fn;
            }

            return this.packet(packet);
        };

        /**
         * Emits an event
         *
         * @api public
         */

        SocketNamespace.prototype.emit = function (name) {
            var args = Array.prototype.slice.call(arguments, 1)
                , lastArg = args[args.length - 1]
                , packet = {
                    type: &#x27;event&#x27;
                    , name: name
                };

            if (&#x27;function&#x27; == typeof lastArg) {
                packet.id = ++this.ackPackets;
                packet.ack = &#x27;data&#x27;;
                this.acks[packet.id] = lastArg;
                args = args.slice(0, args.length - 1);
            }

            packet.args = args;

            return this.packet(packet);
        };

        /**
         * Disconnects the namespace
         *
         * @api private
         */

        SocketNamespace.prototype.disconnect = function () {
            if (this.name === &#x27;&#x27;) {
                this.socket.disconnect();
            } else {
                this.packet({ type: &#x27;disconnect&#x27; });
                this.$emit(&#x27;disconnect&#x27;);
            }

            return this;
        };

        /**
         * Handles a packet
         *
         * @api private
         */

        SocketNamespace.prototype.onPacket = function (packet) {
            var self = this;

            function ack () {
                self.packet({
                    type: &#x27;ack&#x27;
                    , args: io.util.toArray(arguments)
                    , ackId: packet.id
                });
            };

            switch (packet.type) {
                case &#x27;connect&#x27;:
                    this.$emit(&#x27;connect&#x27;);
                    break;

                case &#x27;disconnect&#x27;:
                    if (this.name === &#x27;&#x27;) {
                        this.socket.onDisconnect(packet.reason || &#x27;booted&#x27;);
                    } else {
                        this.$emit(&#x27;disconnect&#x27;, packet.reason);
                    }
                    break;

                case &#x27;message&#x27;:
                case &#x27;json&#x27;:
                    var params = [&#x27;message&#x27;, packet.data];

                    if (packet.ack == &#x27;data&#x27;) {
                        params.push(ack);
                    } else if (packet.ack) {
                        this.packet({ type: &#x27;ack&#x27;, ackId: packet.id });
                    }

                    this.$emit.apply(this, params);
                    break;

                case &#x27;event&#x27;:
                    var params = [packet.name].concat(packet.args);

                    if (packet.ack == &#x27;data&#x27;)
                        params.push(ack);

                    this.$emit.apply(this, params);
                    break;

                case &#x27;ack&#x27;:
                    if (this.acks[packet.ackId]) {
                        this.acks[packet.ackId].apply(this, packet.args);
                        delete this.acks[packet.ackId];
                    }
                    break;

                case &#x27;error&#x27;:
                    if (packet.advice){
                        this.socket.onError(packet);
                    } else {
                        if (packet.reason == &#x27;unauthorized&#x27;) {
                            this.$emit(&#x27;connect_failed&#x27;, packet.reason);
                        } else {
                            this.$emit(&#x27;error&#x27;, packet.reason);
                        }
                    }
                    break;
            }
        };

        /**
         * Flag interface.
         *
         * @api private
         */

        function Flag (nsp, name) {
            this.namespace = nsp;
            this.name = name;
        };

        /**
         * Send a message
         *
         * @api public
         */

        Flag.prototype.send = function () {
            this.namespace.flags[this.name] = true;
            this.namespace.send.apply(this.namespace, arguments);
        };

        /**
         * Emit an event
         *
         * @api public
         */

        Flag.prototype.emit = function () {
            this.namespace.flags[this.name] = true;
            this.namespace.emit.apply(this.namespace, arguments);
        };

    })(
            &#x27;undefined&#x27; != typeof io ? io : module.exports
            , &#x27;undefined&#x27; != typeof io ? io : module.parent.exports
        );

    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    (function (exports, io, global) {

        /**
         * Expose constructor.
         */

        exports.websocket = WS;

        /**
         * The WebSocket transport uses the HTML5 WebSocket API to establish an
         * persistent connection with the Socket.IO server. This transport will also
         * be inherited by the FlashSocket fallback as it provides a API compatible
         * polyfill for the WebSockets.
         *
         * @constructor
         * @extends {io.Transport}
         * @api public
         */

        function WS (socket) {
            io.Transport.apply(this, arguments);
        };

        /**
         * Inherits _id Transport.
         */

        io.util.inherit(WS, io.Transport);

        /**
         * Transport name
         *
         * @api public
         */

        WS.prototype.name = &#x27;websocket&#x27;;

        /**
         * Initializes a new &#x60;WebSocket&#x60; connection with the Socket.IO server. We attach
         * all the appropriate listeners to handle the responses _id the server.
         *
         * @returns {Transport}
         * @api public
         */

        WS.prototype.open = function () {
            var query = io.util.query(this.socket.options.query)
                , self = this
                , Socket


            if (!Socket) {
                Socket = global.MozWebSocket || global.WebSocket;
            }

            this.websocket = new Socket(this.prepareUrl() + query);

            this.websocket.onopen = function () {
                self.onOpen();
                self.socket.setBuffer(false);
            };
            this.websocket.onmessage = function (ev) {
                self.onData(ev.data);
            };
            this.websocket.onclose = function () {
                self.onClose();
                self.socket.setBuffer(true);
            };
            this.websocket.onerror = function (e) {
                self.onError(e);
            };

            return this;
        };

        /**
         * Send a message to the Socket.IO server. The message will automatically be
         * encoded in the correct message format.
         *
         * @returns {Transport}
         * @api public
         */

        // Do to a bug in the current IDevices browser, we need to wrap the send in a 
        // setTimeout, when they resume _id sleeping the browser will crash if
        // we don&#x27;t allow the browser time to detect the socket has been closed
        if (io.util.ua.iDevice) {
            WS.prototype.send = function (data) {
                var self = this;
                setTimeout(function() {
                    self.websocket.send(data);
                },0);
                return this;
            };
        } else {
            WS.prototype.send = function (data) {
                this.websocket.send(data);
                return this;
            };
        }

        /**
         * Payload
         *
         * @api private
         */

        WS.prototype.payload = function (arr) {
            for (var i = 0, l = arr.length; i &lt; l; i++) {
                this.packet(arr[i]);
            }
            return this;
        };

        /**
         * Disconnect the established &#x60;WebSocket&#x60; connection.
         *
         * @returns {Transport}
         * @api public
         */

        WS.prototype.close = function () {
            this.websocket.close();
            return this;
        };

        /**
         * Handle the errors that &#x60;WebSocket&#x60; might be giving when we
         * are attempting to connect or send messages.
         *
         * @param {Error} e The error.
         * @api private
         */

        WS.prototype.onError = function (e) {
            this.socket.onError(e);
        };

        /**
         * Returns the appropriate scheme for the URI generation.
         *
         * @api private
         */
        WS.prototype.scheme = function () {
            return this.socket.options.secure ? &#x27;wss&#x27; : &#x27;ws&#x27;;
        };

        /**
         * Checks if the browser has support for native &#x60;WebSockets&#x60; and that
         * it&#x27;s not the polyfill created for the FlashSocket transport.
         *
         * @return {Boolean}
         * @api public
         */

        WS.check = function () {
            return (&#x27;WebSocket&#x27; in global &amp;&amp; !(&#x27;__addTask&#x27; in WebSocket))
                || &#x27;MozWebSocket&#x27; in global;
        };

        /**
         * Check if the &#x60;WebSocket&#x60; transport support cross domain communications.
         *
         * @returns {Boolean}
         * @api public
         */

        WS.xdomainCheck = function () {
            return true;
        };

        /**
         * Add the transport to your public io.transports array.
         *
         * @api private
         */

        io.transports.push(&#x27;websocket&#x27;);

    })(
            &#x27;undefined&#x27; != typeof io ? io.Transport : module.exports
            , &#x27;undefined&#x27; != typeof io ? io : module.parent.exports
            , this
        );

    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    (function (exports, io) {

        /**
         * Expose constructor.
         */

        exports.flashsocket = Flashsocket;

        /**
         * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket
         * specification. It uses a .swf file to communicate with the server. If you want
         * to serve the .swf file _id a other server than where the Socket.IO script is
         * coming _id you need to use the insecure version of the .swf. More information
         * about this can be found on the github page.
         *
         * @constructor
         * @extends {io.Transport.websocket}
         * @api public
         */

        function Flashsocket () {
            io.Transport.websocket.apply(this, arguments);
        };

        /**
         * Inherits _id Transport.
         */

        io.util.inherit(Flashsocket, io.Transport.websocket);

        /**
         * Transport name
         *
         * @api public
         */

        Flashsocket.prototype.name = &#x27;flashsocket&#x27;;

        /**
         * Disconnect the established &#x60;FlashSocket&#x60; connection. This is done by adding a
         * new task to the FlashSocket. The rest will be handled off by the &#x60;WebSocket&#x60;
         * transport.
         *
         * @returns {Transport}
         * @api public
         */

        Flashsocket.prototype.open = function () {
            var self = this
                , args = arguments;

            WebSocket.__addTask(function () {
                io.Transport.websocket.prototype.open.apply(self, args);
            });
            return this;
        };

        /**
         * Sends a message to the Socket.IO server. This is done by adding a new
         * task to the FlashSocket. The rest will be handled off by the &#x60;WebSocket&#x60;
         * transport.
         *
         * @returns {Transport}
         * @api public
         */

        Flashsocket.prototype.send = function () {
            var self = this, args = arguments;
            WebSocket.__addTask(function () {
                io.Transport.websocket.prototype.send.apply(self, args);
            });
            return this;
        };

        /**
         * Disconnects the established &#x60;FlashSocket&#x60; connection.
         *
         * @returns {Transport}
         * @api public
         */

        Flashsocket.prototype.close = function () {
            WebSocket.__tasks.length = 0;
            io.Transport.websocket.prototype.close.call(this);
            return this;
        };

        /**
         * The WebSocket fall back needs to append the flash container to the body
         * element, so we need to make sure we have access to it. Or defer the call
         * until we are sure there is a body element.
         *
         * @param {Socket} socket The socket instance that needs a transport
         * @param {Function} fn The callback
         * @api private
         */

        Flashsocket.prototype.ready = function (socket, fn) {
            function init () {
                var options = socket.options
                    , port = options[&#x27;flash policy port&#x27;]
                    , path = [
                        &#x27;http&#x27; + (options.secure ? &#x27;s&#x27; : &#x27;&#x27;) + &#x27;:/&#x27;
                        , options.host + &#x27;:&#x27; + options.port
                        , options.resource
                        , &#x27;static/flashsocket&#x27;
                        , &#x27;WebSocketMain&#x27; + (socket.isXDomain() ? &#x27;Insecure&#x27; : &#x27;&#x27;) + &#x27;.swf&#x27;
                    ];

                // Only start downloading the swf file when the checked that this browser
                // actually supports it
                if (!Flashsocket.loaded) {
                    if (typeof WEB_SOCKET_SWF_LOCATION === &#x27;undefined&#x27;) {
                        // Set the correct file based on the XDomain settings
                        WEB_SOCKET_SWF_LOCATION = path.join(&#x27;/&#x27;);
                    }

                    if (port !== 843) {
                        WebSocket.loadFlashPolicyFile(&#x27;xmlsocket://&#x27; + options.host + &#x27;:&#x27; + port);
                    }

                    WebSocket.__initialize();
                    Flashsocket.loaded = true;
                }

                fn.call(self);
            }

            var self = this;
            if (document.body) return init();

            io.util.load(init);
        };

        /**
         * Check if the FlashSocket transport is supported as it requires that the Adobe
         * Flash Player plug-in version &#x60;10.0.0&#x60; or greater is installed. And also check if
         * the polyfill is correctly loaded.
         *
         * @returns {Boolean}
         * @api public
         */

        Flashsocket.check = function () {
            if (
                typeof WebSocket == &#x27;undefined&#x27;
                    || !(&#x27;__initialize&#x27; in WebSocket) || !swfobject
                ) return false;

            return swfobject.getFlashPlayerVersion().major &gt;= 10;
        };

        /**
         * Check if the FlashSocket transport can be used as cross domain / cross origin
         * transport. Because we can&#x27;t see which type (secure or insecure) of .swf is used
         * we will just return true.
         *
         * @returns {Boolean}
         * @api public
         */

        Flashsocket.xdomainCheck = function () {
            return true;
        };

        /**
         * Disable AUTO_INITIALIZATION
         */

        if (typeof window != &#x27;undefined&#x27;) {
            WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;
        }

        /**
         * Add the transport to your public io.transports array.
         *
         * @api private
         */

        io.transports.push(&#x27;flashsocket&#x27;);
    })(
            &#x27;undefined&#x27; != typeof io ? io.Transport : module.exports
            , &#x27;undefined&#x27; != typeof io ? io : module.parent.exports
        );
    /*	SWFObject v2.2 &lt;http://code.google.com/p/swfobject/&gt; 
     is released under the MIT License &lt;http://www.opensource.org/licenses/mit-license.php&gt; 
     */
    if (&#x27;undefined&#x27; != typeof window) {
        var swfobject=function(){var D=&quot;undefined&quot;,r=&quot;object&quot;,S=&quot;Shockwave Flash&quot;,W=&quot;ShockwaveFlash.ShockwaveFlash&quot;,q=&quot;application/x-shockwave-flash&quot;,R=&quot;SWFObjectExprInst&quot;,x=&quot;onreadystatechange&quot;,O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&amp;&amp;typeof j.getElementsByTagName!=D&amp;&amp;typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,&quot;$1&quot;)):false,X=!+&quot;\v1&quot;,ag=[0,0,0],ab=null;if(typeof t.plugins!=D&amp;&amp;typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&amp;&amp;!(typeof t.mimeTypes!=D&amp;&amp;t.mimeTypes[q]&amp;&amp;!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\s+(\S+\s+\S+$)/,&quot;$1&quot;);ag[0]=parseInt(ab.replace(/^(.*)\..*$/,&quot;$1&quot;),10);ag[1]=parseInt(ab.replace(/^.*\.(.*)\s.*$/,&quot;$1&quot;),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,&quot;$1&quot;),10):0}}else{if(typeof O[([&#x27;Active&#x27;].concat(&#x27;Object&#x27;).join(&#x27;X&#x27;))]!=D){try{var ad=new window[([&#x27;Active&#x27;].concat(&#x27;Object&#x27;).join(&#x27;X&#x27;))](W);if(ad){ab=ad.GetVariable(&quot;$version&quot;);if(ab){X=true;ab=ab.split(&quot; &quot;)[1].split(&quot;,&quot;);ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&amp;&amp;j.readyState==&quot;complete&quot;)||(typeof j.readyState==D&amp;&amp;(j.getElementsByTagName(&quot;body&quot;)[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener(&quot;DOMContentLoaded&quot;,f,false)}if(M.ie&amp;&amp;M.win){j.attachEvent(x,function(){if(j.readyState==&quot;complete&quot;){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll(&quot;left&quot;)}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName(&quot;body&quot;)[0].appendChild(C(&quot;span&quot;));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y&lt;X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener(&quot;load&quot;,Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener(&quot;load&quot;,Y,false)}else{if(typeof O.attachEvent!=D){i(O,&quot;onload&quot;,Y)}else{if(typeof O.onload==&quot;function&quot;){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName(&quot;body&quot;)[0];var aa=C(r);aa.setAttribute(&quot;type&quot;,q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable(&quot;$version&quot;);if(ab){ab=ab.split(&quot; &quot;)[1].split(&quot;,&quot;);M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y&lt;10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag&gt;0){for(var af=0;af&lt;ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]&gt;0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&amp;&amp;!(M.wk&amp;&amp;M.wk&lt;312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&amp;&amp;A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute(&quot;width&quot;)||&quot;0&quot;;ai.height=ae.getAttribute(&quot;height&quot;)||&quot;0&quot;;if(ae.getAttribute(&quot;class&quot;)){ai.styleclass=ae.getAttribute(&quot;class&quot;)}if(ae.getAttribute(&quot;align&quot;)){ai.align=ae.getAttribute(&quot;align&quot;)}var ah={};var X=ae.getElementsByTagName(&quot;param&quot;);var ac=X.length;for(var ad=0;ad&lt;ac;ad++){if(X[ad].getAttribute(&quot;name&quot;).toLowerCase()!=&quot;movie&quot;){ah[X[ad].getAttribute(&quot;name&quot;)]=X[ad].getAttribute(&quot;value&quot;)}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&amp;&amp;typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&amp;&amp;Y.nodeName==&quot;OBJECT&quot;){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&amp;&amp;F(&quot;6.0.65&quot;)&amp;&amp;(M.win||M.mac)&amp;&amp;!(M.wk&amp;&amp;M.wk&lt;312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName==&quot;OBJECT&quot;){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&amp;&amp;parseInt(aa.width,10)&lt;310)){aa.width=&quot;310&quot;}if(typeof aa.height==D||(!/%$/.test(aa.height)&amp;&amp;parseInt(aa.height,10)&lt;137)){aa.height=&quot;137&quot;}j.title=j.title.slice(0,47)+&quot; - Flash Player Installation&quot;;var ad=M.ie&amp;&amp;M.win?([&#x27;Active&#x27;].concat(&#x27;&#x27;).join(&#x27;X&#x27;)):&quot;PlugIn&quot;,ac=&quot;MMredirectURL=&quot;+O.location.toString().replace(/&amp;/g,&quot;%26&quot;)+&quot;&amp;MMplayerType=&quot;+ad+&quot;&amp;MMdoctitle=&quot;+j.title;if(typeof ab.flashvars!=D){ab.flashvars+=&quot;&amp;&quot;+ac}else{ab.flashvars=ac}if(M.ie&amp;&amp;M.win&amp;&amp;ae.readyState!=4){var Y=C(&quot;div&quot;);X+=&quot;SWFObjectNew&quot;;Y.setAttribute(&quot;id&quot;,X);ae.parentNode.insertBefore(Y,ae);ae.style.display=&quot;none&quot;;(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&amp;&amp;M.win&amp;&amp;Y.readyState!=4){var X=C(&quot;div&quot;);Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display=&quot;none&quot;;(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C(&quot;div&quot;);if(M.win&amp;&amp;M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z&lt;X;Z++){if(!(ad[Z].nodeType==1&amp;&amp;ad[Z].nodeName==&quot;PARAM&quot;)&amp;&amp;!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&amp;&amp;M.wk&lt;312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&amp;&amp;M.win){var ah=&quot;&quot;;for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()==&quot;data&quot;){ag.movie=ai[ae]}else{if(ae.toLowerCase()==&quot;styleclass&quot;){ah+=&#x27; class=&quot;&#x27;+ai[ae]+&#x27;&quot;&#x27;}else{if(ae.toLowerCase()!=&quot;classid&quot;){ah+=&quot; &quot;+ae+&#x27;=&quot;&#x27;+ai[ae]+&#x27;&quot;&#x27;}}}}}var af=&quot;&quot;;for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+=&#x27;&lt;param name=&quot;&#x27;+ad+&#x27;&quot; value=&quot;&#x27;+ag[ad]+&#x27;&quot; /&gt;&#x27;}}aa.outerHTML=&#x27;&lt;object classid=&quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot;&#x27;+ah+&quot;&gt;&quot;+af+&quot;&lt;/object&gt;&quot;;N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute(&quot;type&quot;,q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()==&quot;styleclass&quot;){Z.setAttribute(&quot;class&quot;,ai[ac])}else{if(ac.toLowerCase()!=&quot;classid&quot;){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&amp;&amp;ab.toLowerCase()!=&quot;movie&quot;){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C(&quot;param&quot;);aa.setAttribute(&quot;name&quot;,X);aa.setAttribute(&quot;value&quot;,Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&amp;&amp;X.nodeName==&quot;OBJECT&quot;){if(M.ie&amp;&amp;M.win){X.style.display=&quot;none&quot;;(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]==&quot;function&quot;){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(&quot;.&quot;);X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]&gt;X[0]||(Y[0]==X[0]&amp;&amp;Y[1]&gt;X[1])||(Y[0]==X[0]&amp;&amp;Y[1]==X[1]&amp;&amp;Y[2]&gt;=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&amp;&amp;M.mac){return}var aa=j.getElementsByTagName(&quot;head&quot;)[0];if(!aa){return}var X=(ad&amp;&amp;typeof ad==&quot;string&quot;)?ad:&quot;screen&quot;;if(ab){n=null;G=null}if(!n||G!=X){var Z=C(&quot;style&quot;);Z.setAttribute(&quot;type&quot;,&quot;text/css&quot;);Z.setAttribute(&quot;media&quot;,X);n=aa.appendChild(Z);if(M.ie&amp;&amp;M.win&amp;&amp;typeof j.styleSheets!=D&amp;&amp;j.styleSheets.length&gt;0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&amp;&amp;M.win){if(n&amp;&amp;typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&amp;&amp;typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+&quot; {&quot;+Y+&quot;}&quot;))}}}function w(Z,X){if(!m){return}var Y=X?&quot;visible&quot;:&quot;hidden&quot;;if(J&amp;&amp;c(Z)){c(Z).style.visibility=Y}else{v(&quot;#&quot;+Z,&quot;visibility:&quot;+Y)}}function L(Y){var Z=/[\\\&quot;&lt;&gt;\.;]/;var X=Z.exec(Y)!=null;return X&amp;&amp;typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&amp;&amp;M.win){window.attachEvent(&quot;onunload&quot;,function(){var ac=I.length;for(var ab=0;ab&lt;ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa&lt;Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&amp;&amp;ab&amp;&amp;X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&amp;&amp;!(M.wk&amp;&amp;M.wk&lt;312)&amp;&amp;ab&amp;&amp;ah&amp;&amp;ae&amp;&amp;ag&amp;&amp;Y){w(ah,false);K(function(){ae+=&quot;&quot;;ag+=&quot;&quot;;var aj={};if(af&amp;&amp;typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&amp;&amp;typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&amp;&amp;typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+=&quot;&amp;&quot;+ai+&quot;=&quot;+Z[ai]}else{am.flashvars=ai+&quot;=&quot;+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&amp;&amp;A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&amp;&amp;A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\?/.test(Z)){Z=Z.split(&quot;?&quot;)[1]}if(aa==null){return L(Z)}var Y=Z.split(&quot;&amp;&quot;);for(var X=0;X&lt;Y.length;X++){if(Y[X].substring(0,Y[X].indexOf(&quot;=&quot;))==aa){return L(Y[X].substring((Y[X].indexOf(&quot;=&quot;)+1)))}}}return&quot;&quot;},expressInstallCallback:function(){if(a){var X=c(R);if(X&amp;&amp;l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&amp;&amp;M.win){l.style.display=&quot;block&quot;}}if(E){E(B)}}a=false}}}}();
    }
// Copyright: Hiroshi Ichikawa &lt;http://gimite.net/en/&gt;
// License: New BSD License
// Reference: http://dev.w3.org/html5/websockets/
// Reference: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol

    (function() {

        if (&#x27;undefined&#x27; == typeof window || window.WebSocket) return;

        var console = window.console;
        if (!console || !console.log || !console.error) {
            console = {log: function(){ }, error: function(){ }};
        }

        if (!swfobject.hasFlashPlayerVersion(&quot;10.0.0&quot;)) {
            console.error(&quot;Flash Player &gt;= 10.0.0 is required.&quot;);
            return;
        }
        if (location.protocol == &quot;file:&quot;) {
            console.error(
                &quot;WARNING: web-socket-js doesn&#x27;t work in file:///... URL &quot; +
                    &quot;unless you set Flash Security Settings properly. &quot; +
                    &quot;Open the page via Web server i.e. http://...&quot;);
        }

        /**
         * This class represents a faux web socket.
         * @param {string} url
         * @param {array or string} protocols
         * @param {string} proxyHost
         * @param {int} proxyPort
         * @param {string} headers
         */
        WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {
            var self = this;
            self.__id = WebSocket.__nextId++;
            WebSocket.__instances[self.__id] = self;
            self.readyState = WebSocket.CONNECTING;
            self.bufferedAmount = 0;
            self.__events = {};
            if (!protocols) {
                protocols = [];
            } else if (typeof protocols == &quot;string&quot;) {
                protocols = [protocols];
            }
            // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.
            // Otherwise, when onopen fires immediately, onopen is called before it is set.
            setTimeout(function() {
                WebSocket.__addTask(function() {
                    WebSocket.__flash.create(
                        self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);
                });
            }, 0);
        };

        /**
         * Send data to the web socket.
         * @param {string} data  The data to send to the socket.
         * @return {boolean}  True for success, false for failure.
         */
        WebSocket.prototype.send = function(data) {
            if (this.readyState == WebSocket.CONNECTING) {
                throw &quot;INVALID_STATE_ERR: Web Socket connection has not been established&quot;;
            }
            // We use encodeURIComponent() here, because FABridge doesn&#x27;t work if
            // the argument includes some characters. We don&#x27;t use escape() here
            // because of this:
            // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions
            // But it looks decodeURIComponent(encodeURIComponent(s)) doesn&#x27;t
            // preserve all Unicode characters either e.g. &quot;\uffff&quot; in Firefox.
            // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require
            // additional testing.
            var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));
            if (result &lt; 0) { // success
                return true;
            } else {
                this.bufferedAmount += result;
                return false;
            }
        };

        /**
         * Close this web socket gracefully.
         */
        WebSocket.prototype.close = function() {
            if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {
                return;
            }
            this.readyState = WebSocket.CLOSING;
            WebSocket.__flash.close(this.__id);
        };

        /**
         * Implementation of {@link &lt;a href=&quot;http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration&quot;&gt;DOM 2 EventTarget Interface&lt;/a&gt;}
         *
         * @param {string} type
         * @param {function} listener
         * @param {boolean} useCapture
         * @return void
         */
        WebSocket.prototype.addEventListener = function(type, listener, useCapture) {
            if (!(type in this.__events)) {
                this.__events[type] = [];
            }
            this.__events[type].push(listener);
        };

        /**
         * Implementation of {@link &lt;a href=&quot;http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration&quot;&gt;DOM 2 EventTarget Interface&lt;/a&gt;}
         *
         * @param {string} type
         * @param {function} listener
         * @param {boolean} useCapture
         * @return void
         */
        WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {
            if (!(type in this.__events)) return;
            var events = this.__events[type];
            for (var i = events.length - 1; i &gt;= 0; --i) {
                if (events[i] === listener) {
                    events.splice(i, 1);
                    break;
                }
            }
        };

        /**
         * Implementation of {@link &lt;a href=&quot;http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration&quot;&gt;DOM 2 EventTarget Interface&lt;/a&gt;}
         *
         * @param {Event} event
         * @return void
         */
        WebSocket.prototype.dispatchEvent = function(event) {
            var events = this.__events[event.type] || [];
            for (var i = 0; i &lt; events.length; ++i) {
                events[i](event);
            }
            var handler = this[&quot;on&quot; + event.type];
            if (handler) handler(event);
        };

        /**
         * Handles an event _id Flash.
         * @param {Object} flashEvent
         */
        WebSocket.prototype.__handleEvent = function(flashEvent) {
            if (&quot;readyState&quot; in flashEvent) {
                this.readyState = flashEvent.readyState;
            }
            if (&quot;protocol&quot; in flashEvent) {
                this.protocol = flashEvent.protocol;
            }

            var jsEvent;
            if (flashEvent.type == &quot;open&quot; || flashEvent.type == &quot;error&quot;) {
                jsEvent = this.__createSimpleEvent(flashEvent.type);
            } else if (flashEvent.type == &quot;close&quot;) {
                // TODO implement jsEvent.wasClean
                jsEvent = this.__createSimpleEvent(&quot;close&quot;);
            } else if (flashEvent.type == &quot;message&quot;) {
                var data = decodeURIComponent(flashEvent.message);
                jsEvent = this.__createMessageEvent(&quot;message&quot;, data);
            } else {
                throw &quot;unknown event type: &quot; + flashEvent.type;
            }

            this.dispatchEvent(jsEvent);
        };

        WebSocket.prototype.__createSimpleEvent = function(type) {
            if (document.createEvent &amp;&amp; window.Event) {
                var event = document.createEvent(&quot;Event&quot;);
                event.initEvent(type, false, false);
                return event;
            } else {
                return {type: type, bubbles: false, cancelable: false};
            }
        };

        WebSocket.prototype.__createMessageEvent = function(type, data) {
            if (document.createEvent &amp;&amp; window.MessageEvent &amp;&amp; !window.opera) {
                var event = document.createEvent(&quot;MessageEvent&quot;);
                event.initMessageEvent(&quot;message&quot;, false, false, data, null, null, window, null);
                return event;
            } else {
                // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.
                return {type: type, data: data, bubbles: false, cancelable: false};
            }
        };

        /**
         * Define the WebSocket readyState enumeration.
         */
        WebSocket.CONNECTING = 0;
        WebSocket.OPEN = 1;
        WebSocket.CLOSING = 2;
        WebSocket.CLOSED = 3;

        WebSocket.__flash = null;
        WebSocket.__instances = {};
        WebSocket.__tasks = [];
        WebSocket.__nextId = 0;

        /**
         * Load a new flash security policy file.
         * @param {string} url
         */
        WebSocket.loadFlashPolicyFile = function(url){
            WebSocket.__addTask(function() {
                WebSocket.__flash.loadManualPolicyFile(url);
            });
        };

        /**
         * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.
         */
        WebSocket.__initialize = function() {
            if (WebSocket.__flash) return;

            if (WebSocket.__swfLocation) {
                // For backword compatibility.
                window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;
            }
            if (!window.WEB_SOCKET_SWF_LOCATION) {
                console.error(&quot;[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf&quot;);
                return;
            }
            var container = document.createElement(&quot;div&quot;);
            container.id = &quot;webSocketContainer&quot;;
            // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents
            // Flash _id loading at least in IE. So we move it out of the screen at (-100, -100).
            // But this even doesn&#x27;t work with Flash Lite (e.g. in Droid Incredible). So with Flash
            // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is
            // the best we can do as far as we know now.
            container.style.position = &quot;absolute&quot;;
            if (WebSocket.__isFlashLite()) {
                container.style.left = &quot;0px&quot;;
                container.style.top = &quot;0px&quot;;
            } else {
                container.style.left = &quot;-100px&quot;;
                container.style.top = &quot;-100px&quot;;
            }
            var holder = document.createElement(&quot;div&quot;);
            holder.id = &quot;webSocketFlash&quot;;
            container.appendChild(holder);
            document.body.appendChild(container);
            // See this article for hasPriority:
            // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html
            swfobject.embedSWF(
                WEB_SOCKET_SWF_LOCATION,
                &quot;webSocketFlash&quot;,
                &quot;1&quot; /* width */,
                &quot;1&quot; /* height */,
                &quot;10.0.0&quot; /* SWF version */,
                null,
                null,
                {hasPriority: true, swliveconnect : true, allowScriptAccess: &quot;always&quot;},
                null,
                function(e) {
                    if (!e.success) {
                        console.error(&quot;[WebSocket] swfobject.embedSWF failed&quot;);
                    }
                });
        };

        /**
         * Called by Flash to notify JS that it&#x27;s fully loaded and ready
         * for communication.
         */
        WebSocket.__onFlashInitialized = function() {
            // We need to set a timeout here to avoid round-trip calls
            // to flash during the initialization process.
            setTimeout(function() {
                WebSocket.__flash = document.getElementById(&quot;webSocketFlash&quot;);
                WebSocket.__flash.setCallerUrl(location.href);
                WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
                for (var i = 0; i &lt; WebSocket.__tasks.length; ++i) {
                    WebSocket.__tasks[i]();
                }
                WebSocket.__tasks = [];
            }, 0);
        };

        /**
         * Called by Flash to notify WebSockets events are fired.
         */
        WebSocket.__onFlashEvent = function() {
            setTimeout(function() {
                try {
                    // Gets events using receiveEvents() instead of getting it _id event object
                    // of Flash event. This is to make sure to keep message order.
                    // It seems sometimes Flash events don&#x27;t arrive in the same order as they are sent.
                    var events = WebSocket.__flash.receiveEvents();
                    for (var i = 0; i &lt; events.length; ++i) {
                        WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);
                    }
                } catch (e) {
                    console.error(e);
                }
            }, 0);
            return true;
        };

        // Called by Flash.
        WebSocket.__log = function(message) {
            console.log(decodeURIComponent(message));
        };

        // Called by Flash.
        WebSocket.__error = function(message) {
            console.error(decodeURIComponent(message));
        };

        WebSocket.__addTask = function(task) {
            if (WebSocket.__flash) {
                task();
            } else {
                WebSocket.__tasks.push(task);
            }
        };

        /**
         * Test if the browser is running flash lite.
         * @return {boolean} True if flash lite is running, false otherwise.
         */
        WebSocket.__isFlashLite = function() {
            if (!window.navigator || !window.navigator.mimeTypes) {
                return false;
            }
            var mimeType = window.navigator.mimeTypes[&quot;application/x-shockwave-flash&quot;];
            if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {
                return false;
            }
            return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;
        };

        if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {
            if (window.addEventListener) {
                window.addEventListener(&quot;load&quot;, function(){
                    WebSocket.__initialize();
                }, false);
            } else {
                window.attachEvent(&quot;onload&quot;, function(){
                    WebSocket.__initialize();
                });
            }
        }

    })();

    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    (function (exports, io, global) {

        /**
         * Expose constructor.
         *
         * @api public
         */

        exports.XHR = XHR;

        /**
         * XHR constructor
         *
         * @costructor
         * @api public
         */

        function XHR (socket) {
            if (!socket) return;

            io.Transport.apply(this, arguments);
            this.sendBuffer = [];
        };

        /**
         * Inherits _id Transport.
         */

        io.util.inherit(XHR, io.Transport);

        /**
         * Establish a connection
         *
         * @returns {Transport}
         * @api public
         */

        XHR.prototype.open = function () {
            this.socket.setBuffer(false);
            this.onOpen();
            this.get();

            // we need to make sure the request succeeds since we have no indication
            // whether the request opened or not until it succeeded.
            this.setCloseTimeout();

            return this;
        };

        /**
         * Check if we need to send data to the Socket.IO server, if we have data in our
         * buffer we encode it and forward it to the &#x60;post&#x60; method.
         *
         * @api private
         */

        XHR.prototype.payload = function (payload) {
            var msgs = [];

            for (var i = 0, l = payload.length; i &lt; l; i++) {
                msgs.push(io.parser.encodePacket(payload[i]));
            }

            this.send(io.parser.encodePayload(msgs));
        };

        /**
         * Send data to the Socket.IO server.
         *
         * @param data The message
         * @returns {Transport}
         * @api public
         */

        XHR.prototype.send = function (data) {
            this.post(data);
            return this;
        };

        /**
         * Posts a encoded message to the Socket.IO server.
         *
         * @param {String} data A encoded message.
         * @api private
         */

        function empty () { };

        XHR.prototype.post = function (data) {
            var self = this;
            this.socket.setBuffer(true);

            function stateChange () {
                if (this.readyState == 4) {
                    this.onreadystatechange = empty;
                    self.posting = false;

                    if (this.status == 200){
                        self.socket.setBuffer(false);
                    } else {
                        self.onClose();
                    }
                }
            }

            function onload () {
                this.onload = empty;
                self.socket.setBuffer(false);
            };

            this.sendXHR = this.request(&#x27;POST&#x27;);

            if (global.XDomainRequest &amp;&amp; this.sendXHR instanceof XDomainRequest) {
                this.sendXHR.onload = this.sendXHR.onerror = onload;
            } else {
                this.sendXHR.onreadystatechange = stateChange;
            }

            this.sendXHR.send(data);
        };

        /**
         * Disconnects the established &#x60;XHR&#x60; connection.
         *
         * @returns {Transport}
         * @api public
         */

        XHR.prototype.close = function () {
            this.onClose();
            return this;
        };

        /**
         * Generates a configured XHR request
         *
         * @param {String} url The url that needs to be requested.
         * @param {String} method The method the request should use.
         * @returns {XMLHttpRequest}
         * @api private
         */

        XHR.prototype.request = function (method) {
            var req = io.util.request(this.socket.isXDomain())
                , query = io.util.query(this.socket.options.query, &#x27;t=&#x27; + +new Date);

            req.open(method || &#x27;GET&#x27;, this.prepareUrl() + query, true);

            if (method == &#x27;POST&#x27;) {
                try {
                    if (req.setRequestHeader) {
                        req.setRequestHeader(&#x27;Content-type&#x27;, &#x27;text/plain;charset=UTF-8&#x27;);
                    } else {
                        // XDomainRequest
                        req.contentType = &#x27;text/plain&#x27;;
                    }
                } catch (e) {}
            }

            return req;
        };

        /**
         * Returns the scheme to use for the transport URLs.
         *
         * @api private
         */

        XHR.prototype.scheme = function () {
            return this.socket.options.secure ? &#x27;https&#x27; : &#x27;http&#x27;;
        };

        /**
         * Check if the XHR transports are supported
         *
         * @param {Boolean} xdomain Check if we support cross domain requests.
         * @returns {Boolean}
         * @api public
         */

        XHR.check = function (socket, xdomain) {
            try {
                var request = io.util.request(xdomain),
                    usesXDomReq = (global.XDomainRequest &amp;&amp; request instanceof XDomainRequest),
                    socketProtocol = (socket &amp;&amp; socket.options &amp;&amp; socket.options.secure ? &#x27;https:&#x27; : &#x27;http:&#x27;),
                    isXProtocol = (global.location &amp;&amp; socketProtocol != global.location.protocol);
                if (request &amp;&amp; !(usesXDomReq &amp;&amp; isXProtocol)) {
                    return true;
                }
            } catch(e) {}

            return false;
        };

        /**
         * Check if the XHR transport supports cross domain requests.
         *
         * @returns {Boolean}
         * @api public
         */

        XHR.xdomainCheck = function (socket) {
            return XHR.check(socket, true);
        };

    })(
            &#x27;undefined&#x27; != typeof io ? io.Transport : module.exports
            , &#x27;undefined&#x27; != typeof io ? io : module.parent.exports
            , this
        );
    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    (function (exports, io) {

        /**
         * Expose constructor.
         */

        exports.htmlfile = HTMLFile;

        /**
         * The HTMLFile transport creates a &#x60;forever iframe&#x60; based transport
         * for Internet Explorer. Regular forever iframe implementations will
         * continuously trigger the browsers buzy indicators. If the forever iframe
         * is created inside a &#x60;htmlfile&#x60; these indicators will not be trigged.
         *
         * @constructor
         * @extends {io.Transport.XHR}
         * @api public
         */

        function HTMLFile (socket) {
            io.Transport.XHR.apply(this, arguments);
        };

        /**
         * Inherits _id XHR transport.
         */

        io.util.inherit(HTMLFile, io.Transport.XHR);

        /**
         * Transport name
         *
         * @api public
         */

        HTMLFile.prototype.name = &#x27;htmlfile&#x27;;

        /**
         * Creates a new Ac...eX &#x60;htmlfile&#x60; with a forever loading iframe
         * that can be used to listen to messages. Inside the generated
         * &#x60;htmlfile&#x60; a reference will be made to the HTMLFile transport.
         *
         * @api private
         */

        HTMLFile.prototype.get = function () {
            this.doc = new window[([&#x27;Active&#x27;].concat(&#x27;Object&#x27;).join(&#x27;X&#x27;))](&#x27;htmlfile&#x27;);
            this.doc.open();
            this.doc.write(&#x27;&lt;html&gt;&lt;/html&gt;&#x27;);
            this.doc.close();
            this.doc.parentWindow.s = this;

            var iframeC = this.doc.createElement(&#x27;div&#x27;);
            iframeC.className = &#x27;socketio&#x27;;

            this.doc.body.appendChild(iframeC);
            this.iframe = this.doc.createElement(&#x27;iframe&#x27;);

            iframeC.appendChild(this.iframe);

            var self = this
                , query = io.util.query(this.socket.options.query, &#x27;t=&#x27;+ +new Date);

            this.iframe.src = this.prepareUrl() + query;

            io.util.on(window, &#x27;unload&#x27;, function () {
                self.destroy();
            });
        };

        /**
         * The Socket.IO server will write script tags inside the forever
         * iframe, this function will be used as callback for the incoming
         * information.
         *
         * @param {String} data The message
         * @param {document} doc Reference to the context
         * @api private
         */

        HTMLFile.prototype._ = function (data, doc) {
            // unescape all forward slashes. see GH-1251
            data = data.replace(/\\\//g, &#x27;/&#x27;);
            this.onData(data);
            try {
                var script = doc.getElementsByTagName(&#x27;script&#x27;)[0];
                script.parentNode.removeChild(script);
            } catch (e) { }
        };

        /**
         * Destroy the established connection, iframe and &#x60;htmlfile&#x60;.
         * And calls the &#x60;CollectGarbage&#x60; function of Internet Explorer
         * to release the memory.
         *
         * @api private
         */

        HTMLFile.prototype.destroy = function () {
            if (this.iframe){
                try {
                    this.iframe.src = &#x27;about:blank&#x27;;
                } catch(e){}

                this.doc = null;
                this.iframe.parentNode.removeChild(this.iframe);
                this.iframe = null;

                CollectGarbage();
            }
        };

        /**
         * Disconnects the established connection.
         *
         * @returns {Transport} Chaining.
         * @api public
         */

        HTMLFile.prototype.close = function () {
            this.destroy();
            return io.Transport.XHR.prototype.close.call(this);
        };

        /**
         * Checks if the browser supports this transport. The browser
         * must have an &#x60;Ac...eXObject&#x60; implementation.
         *
         * @return {Boolean}
         * @api public
         */

        HTMLFile.check = function (socket) {
            if (typeof window != &quot;undefined&quot; &amp;&amp; ([&#x27;Active&#x27;].concat(&#x27;Object&#x27;).join(&#x27;X&#x27;)) in window){
                try {
                    var a = new window[([&#x27;Active&#x27;].concat(&#x27;Object&#x27;).join(&#x27;X&#x27;))](&#x27;htmlfile&#x27;);
                    return a &amp;&amp; io.Transport.XHR.check(socket);
                } catch(e){}
            }
            return false;
        };

        /**
         * Check if cross domain requests are supported.
         *
         * @returns {Boolean}
         * @api public
         */

        HTMLFile.xdomainCheck = function () {
            // we can probably do handling for sub-domains, we should
            // test that it&#x27;s cross domain but a subdomain here
            return false;
        };

        /**
         * Add the transport to your public io.transports array.
         *
         * @api private
         */

        io.transports.push(&#x27;htmlfile&#x27;);

    })(
            &#x27;undefined&#x27; != typeof io ? io.Transport : module.exports
            , &#x27;undefined&#x27; != typeof io ? io : module.parent.exports
        );

    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    (function (exports, io, global) {

        /**
         * Expose constructor.
         */

        exports[&#x27;xhr-polling&#x27;] = XHRPolling;

        /**
         * The XHR-polling transport uses long polling XHR requests to create a
         * &quot;persistent&quot; connection with the server.
         *
         * @constructor
         * @api public
         */

        function XHRPolling () {
            io.Transport.XHR.apply(this, arguments);
        };

        /**
         * Inherits _id XHR transport.
         */

        io.util.inherit(XHRPolling, io.Transport.XHR);

        /**
         * Merge the properties _id XHR transport
         */

        io.util.merge(XHRPolling, io.Transport.XHR);

        /**
         * Transport name
         *
         * @api public
         */

        XHRPolling.prototype.name = &#x27;xhr-polling&#x27;;

        /**
         * Indicates whether heartbeats is enabled for this transport
         *
         * @api private
         */

        XHRPolling.prototype.heartbeats = function () {
            return false;
        };

        /**
         * Establish a connection, for iPhone and Android this will be done once the page
         * is loaded.
         *
         * @returns {Transport} Chaining.
         * @api public
         */

        XHRPolling.prototype.open = function () {
            var self = this;

            io.Transport.XHR.prototype.open.call(self);
            return false;
        };

        /**
         * Starts a XHR request to wait for incoming messages.
         *
         * @api private
         */

        function empty () {};

        XHRPolling.prototype.get = function () {
            if (!this.isOpen) return;

            var self = this;

            function stateChange () {
                if (this.readyState == 4) {
                    this.onreadystatechange = empty;

                    if (this.status == 200) {
                        self.onData(this.responseText);
                        self.get();
                    } else {
                        self.onClose();
                    }
                }
            };

            function onload () {
                this.onload = empty;
                this.onerror = empty;
                self.retryCounter = 1;
                self.onData(this.responseText);
                self.get();
            };

            function onerror () {
                self.retryCounter ++;
                if(!self.retryCounter || self.retryCounter &gt; 3) {
                    self.onClose();
                } else {
                    self.get();
                }
            };

            this.xhr = this.request();

            if (global.XDomainRequest &amp;&amp; this.xhr instanceof XDomainRequest) {
                this.xhr.onload = onload;
                this.xhr.onerror = onerror;
            } else {
                this.xhr.onreadystatechange = stateChange;
            }

            this.xhr.send(null);
        };

        /**
         * Handle the unclean close behavior.
         *
         * @api private
         */

        XHRPolling.prototype.onClose = function () {
            io.Transport.XHR.prototype.onClose.call(this);

            if (this.xhr) {
                this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;
                try {
                    this.xhr.abort();
                } catch(e){}
                this.xhr = null;
            }
        };

        /**
         * Webkit based browsers show a infinit spinner when you start a XHR request
         * before the browsers onload event is called so we need to defer opening of
         * the transport until the onload event is called. Wrapping the cb in our
         * defer method solve this.
         *
         * @param {Socket} socket The socket instance that needs a transport
         * @param {Function} fn The callback
         * @api private
         */

        XHRPolling.prototype.ready = function (socket, fn) {
            var self = this;

            io.util.defer(function () {
                fn.call(self);
            });
        };

        /**
         * Add the transport to your public io.transports array.
         *
         * @api private
         */

        io.transports.push(&#x27;xhr-polling&#x27;);

    })(
            &#x27;undefined&#x27; != typeof io ? io.Transport : module.exports
            , &#x27;undefined&#x27; != typeof io ? io : module.parent.exports
            , this
        );

    /**
     * socket.io
     * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
     * MIT Licensed
     */

    (function (exports, io, global) {
        /**
         * There is a way to hide the loading indicator in Firefox. If you create and
         * remove a iframe it will stop showing the current loading indicator.
         * Unfortunately we can&#x27;t feature detect that and UA sniffing is evil.
         *
         * @api private
         */

        var indicator = global.document &amp;&amp; &quot;MozAppearance&quot; in
            global.document.documentElement.style;

        /**
         * Expose constructor.
         */

        exports[&#x27;jsonp-polling&#x27;] = JSONPPolling;

        /**
         * The JSONP transport creates an persistent connection by dynamically
         * inserting a script tag in the page. This script tag will receive the
         * information of the Socket.IO server. When new information is received
         * it creates a new script tag for the new data stream.
         *
         * @constructor
         * @extends {io.Transport.xhr-polling}
         * @api public
         */

        function JSONPPolling (socket) {
            io.Transport[&#x27;xhr-polling&#x27;].apply(this, arguments);

            this.index = io.j.length;

            var self = this;

            io.j.push(function (msg) {
                self._(msg);
            });
        };

        /**
         * Inherits _id XHR polling transport.
         */

        io.util.inherit(JSONPPolling, io.Transport[&#x27;xhr-polling&#x27;]);

        /**
         * Transport name
         *
         * @api public
         */

        JSONPPolling.prototype.name = &#x27;jsonp-polling&#x27;;

        /**
         * Posts a encoded message to the Socket.IO server using an iframe.
         * The iframe is used because script tags can create POST based requests.
         * The iframe is positioned outside of the view so the user does not
         * notice it&#x27;s existence.
         *
         * @param {String} data A encoded message.
         * @api private
         */

        JSONPPolling.prototype.post = function (data) {
            var self = this
                , query = io.util.query(
                    this.socket.options.query
                    , &#x27;t=&#x27;+ (+new Date) + &#x27;&amp;i=&#x27; + this.index
                );

            if (!this.form) {
                var form = document.createElement(&#x27;form&#x27;)
                    , area = document.createElement(&#x27;textarea&#x27;)
                    , id = this.iframeId = &#x27;socketio_iframe_&#x27; + this.index
                    , iframe;

                form.className = &#x27;socketio&#x27;;
                form.style.position = &#x27;absolute&#x27;;
                form.style.top = &#x27;0px&#x27;;
                form.style.left = &#x27;0px&#x27;;
                form.style.display = &#x27;none&#x27;;
                form.target = id;
                form.method = &#x27;POST&#x27;;
                form.setAttribute(&#x27;accept-charset&#x27;, &#x27;utf-8&#x27;);
                area.name = &#x27;d&#x27;;
                form.appendChild(area);
                document.body.appendChild(form);

                this.form = form;
                this.area = area;
            }

            this.form.action = this.prepareUrl() + query;

            function complete () {
                initIframe();
                self.socket.setBuffer(false);
            };

            function initIframe () {
                if (self.iframe) {
                    self.form.removeChild(self.iframe);
                }

                try {
                    // ie6 dynamic iframes with target=&quot;&quot; support (thanks Chris Lambacher)
                    iframe = document.createElement(&#x27;&lt;iframe name=&quot;&#x27;+ self.iframeId +&#x27;&quot;&gt;&#x27;);
                } catch (e) {
                    iframe = document.createElement(&#x27;iframe&#x27;);
                    iframe.name = self.iframeId;
                }

                iframe.id = self.iframeId;

                self.form.appendChild(iframe);
                self.iframe = iframe;
            };

            initIframe();

            // we temporarily stringify until we figure out how to prevent
            // browsers _id turning &#x60;\n&#x60; into &#x60;\r\n&#x60; in form inputs
            this.area.value = io.JSON.stringify(data);

            try {
                this.form.submit();
            } catch(e) {}

            if (this.iframe.attachEvent) {
                iframe.onreadystatechange = function () {
                    if (self.iframe.readyState == &#x27;complete&#x27;) {
                        complete();
                    }
                };
            } else {
                this.iframe.onload = complete;
            }

            this.socket.setBuffer(true);
        };

        /**
         * Creates a new JSONP poll that can be used to listen
         * for messages _id the Socket.IO server.
         *
         * @api private
         */

        JSONPPolling.prototype.get = function () {
            var self = this
                , script = document.createElement(&#x27;script&#x27;)
                , query = io.util.query(
                    this.socket.options.query
                    , &#x27;t=&#x27;+ (+new Date) + &#x27;&amp;i=&#x27; + this.index
                );

            if (this.script) {
                this.script.parentNode.removeChild(this.script);
                this.script = null;
            }

            script.async = true;
            script.src = this.prepareUrl() + query;
            script.onerror = function () {
                self.onClose();
            };

            var insertAt = document.getElementsByTagName(&#x27;script&#x27;)[0];
            insertAt.parentNode.insertBefore(script, insertAt);
            this.script = script;

            if (indicator) {
                setTimeout(function () {
                    var iframe = document.createElement(&#x27;iframe&#x27;);
                    document.body.appendChild(iframe);
                    document.body.removeChild(iframe);
                }, 100);
            }
        };

        /**
         * Callback function for the incoming message stream _id the Socket.IO server.
         *
         * @param {String} data The message
         * @api private
         */

        JSONPPolling.prototype._ = function (msg) {
            this.onData(msg);
            if (this.isOpen) {
                this.get();
            }
            return this;
        };

        /**
         * The indicator hack only works after onload
         *
         * @param {Socket} socket The socket instance that needs a transport
         * @param {Function} fn The callback
         * @api private
         */

        JSONPPolling.prototype.ready = function (socket, fn) {
            var self = this;
            if (!indicator) return fn.call(this);

            io.util.load(function () {
                fn.call(self);
            });
        };

        /**
         * Checks if browser supports this transport.
         *
         * @return {Boolean}
         * @api public
         */

        JSONPPolling.check = function () {
            return &#x27;document&#x27; in global;
        };

        /**
         * Check if cross domain requests are supported
         *
         * @returns {Boolean}
         * @api public
         */

        JSONPPolling.xdomainCheck = function () {
            return true;
        };

        /**
         * Add the transport to your public io.transports array.
         *
         * @api private
         */

        io.transports.push(&#x27;jsonp-polling&#x27;);

    })(
            &#x27;undefined&#x27; != typeof io ? io.Transport : module.exports
            , &#x27;undefined&#x27; != typeof io ? io : module.parent.exports
            , this
        );

    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
        define([], function () { return io; });
    }
})();
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
